
> disabletabs@1.2.0 run /home/kousu/src/web/disabletabs
> jpm run -b `which firefox` --binary-args github.com

JPM [info] Starting jpm run on Disable Tabs
JPM [info] Creating a new profile
console.log: disabletabs: properties of [object XULElement]:
console.log: disabletabs: [object XULElement].mCurrentBrowser = [object XULElement]
console.log: disabletabs: [object XULElement].tabContainer = [object XULElement]
console.log: disabletabs: [object XULElement].mCurrentTab = [object XULElement]
console.log: disabletabs: [object XULElement].AppConstants = [object Object]
console.log: disabletabs: [object XULElement]._uniquePanelIDCounter = 1
console.log: disabletabs: [object XULElement].mPanelContainer = [object XULElement]
console.log: disabletabs: [object XULElement]._tabForBrowser = [object WeakMap]
console.log: disabletabs: [object XULElement]._autoScrollPopup = [object XULElement]
console.log: disabletabs: [object XULElement].mTabListeners = [object Object]
console.log: disabletabs: [object XULElement].mTabFilters = [xpconnect wrapped nsIWebProgress]
console.log: disabletabs: [object XULElement]._outerWindowIDBrowserMap = [object Map]
console.log: disabletabs: [object XULElement]._placesAutocomplete = [xpconnect wrapped mozIPlacesAutoComplete]
console.log: disabletabs: [object XULElement]._unifiedComplete = [xpconnect wrapped mozIPlacesAutoComplete]
console.log: disabletabs: [object XULElement].mTabBox = [object XULElement]
console.log: disabletabs: [object XULElement].mStringBundle = [object XULElement]
console.log: disabletabs: [object XULElement].mProgressListeners = 
console.log: disabletabs: [object XULElement].mTabsProgressListeners = 
console.log: disabletabs: [object XULElement].mURIFixup = [xpconnect wrapped nsIURIFixup]
console.log: disabletabs: [object XULElement].mIsBusy = false
console.log: disabletabs: [object XULElement].tabContextMenu = [object XULElement]
console.log: disabletabs: [object XULElement].visibleTabs = [object XULElement]
console.log: disabletabs: [object XULElement]._numPinnedTabs = 0
console.log: disabletabs: [object XULElement].formValidationAnchor = [object XULElement]
console.log: disabletabs: [object XULElement].isFindBarInitialized = function isFindBarInitialized(aTab) {

          return (aTab || this.selectedTab)._findBar != undefined;
        
}
console.log: disabletabs: [object XULElement].getFindBar = function getFindBar(aTab) {

          if (!aTab)
            aTab = this.selectedTab;

          if (aTab._findBar)
            return aTab._findBar;

          let findBar = document.createElementNS(this.namespaceURI, "findbar");
          let browser = this.getBrowserForTab(aTab);
          let browserContainer = this.getBrowserContainer(browser);
          browserContainer.appendChild(findBar);

          // Force a style flush to ensure that our binding is attached.
          findBar.clientTop;

          findBar.browser = browser;
          findBar._findField.value = this._lastFindValue;

          aTab._findBar = findBar;

          let event = document.createEvent("Events");
          event.initEvent("TabFindInitialized", true, false);
          aTab.dispatchEvent(event);

          return findBar;
        
}
console.log: disabletabs: [object XULElement].getStatusPanel = function getStatusPanel() {

          if (!this._statusPanel) {
            this._statusPanel = document.createElementNS(this.namespaceURI, "statuspanel");
            this._statusPanel.setAttribute("inactive", "true");
            this._statusPanel.setAttribute("layer", "true");
            this._appendStatusPanel();
          }
          return this._statusPanel;
        
}
console.log: disabletabs: [object XULElement]._appendStatusPanel = function _appendStatusPanel() {

          if (this._statusPanel) {
            let browser = this.selectedBrowser;
            let browserContainer = this.getBrowserContainer(browser);
            browserContainer.insertBefore(this._statusPanel, browser.parentNode.nextSibling);
          }
        
}
console.log: disabletabs: [object XULElement].updateWindowResizers = function updateWindowResizers() {

          if (!window.gShowPageResizers)
            return;

          var show = window.windowState == window.STATE_NORMAL;
          for (let i = 0; i < this.browsers.length; i++) {
            this.browsers[i].showWindowResizer = show;
          }
        
}
console.log: disabletabs: [object XULElement]._setCloseKeyState = function _setCloseKeyState(aEnabled) {

          let keyClose = document.getElementById("key_close");
          let closeKeyEnabled = keyClose.getAttribute("disabled") != "true";
          if (closeKeyEnabled == aEnabled)
            return;

          if (aEnabled)
            keyClose.removeAttribute("disabled");
          else
            keyClose.setAttribute("disabled", "true");

          // We also want to remove the keyboard shortcut from the file menu
          // when the shortcut is disabled, and bring it back when it's
          // renabled.
          //
          // Fixing bug 630826 could make that happen automatically.
          // Fixing bug 630830 could avoid the ugly hack below.

          let closeMenuItem = document.getElementById("menu_close");
          let parentPopup = closeMenuItem.parentNode;
          let nextItem = closeMenuItem.nextSibling;
          let clonedItem = closeMenuItem.cloneNode(true);

          parentPopup.removeChild(closeMenuItem);

          if (aEnabled)
            clonedItem.setAttribute("key", "key_close");
          else
            clonedItem.removeAttribute("key");

          parentPopup.insertBefore(clonedItem, nextItem);
        
}
console.log: disabletabs: [object XULElement].pinTab = function pinTab(aTab) {

          if (aTab.pinned)
            return;

          if (aTab.hidden)
            this.showTab(aTab);

          this.moveTabTo(aTab, this._numPinnedTabs);
          aTab.setAttribute("pinned", "true");
          this.tabContainer._unlockTabSizing();
          this.tabContainer._positionPinnedTabs();
          this.tabContainer.adjustTabstrip();

          this.getBrowserForTab(aTab).messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: true })

          if (aTab.selected)
            this._setCloseKeyState(false);

          let event = document.createEvent("Events");
          event.initEvent("TabPinned", true, false);
          aTab.dispatchEvent(event);
        
}
console.log: disabletabs: [object XULElement].unpinTab = function unpinTab(aTab) {

          if (!aTab.pinned)
            return;

          this.moveTabTo(aTab, this._numPinnedTabs - 1);
          aTab.removeAttribute("pinned");
          aTab.style.MozMarginStart = "";
          this.tabContainer._unlockTabSizing();
          this.tabContainer._positionPinnedTabs();
          this.tabContainer.adjustTabstrip();

          this.getBrowserForTab(aTab).messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: false })

          if (aTab.selected)
            this._setCloseKeyState(true);

          let event = document.createEvent("Events");
          event.initEvent("TabUnpinned", true, false);
          aTab.dispatchEvent(event);
        
}
console.log: disabletabs: [object XULElement].previewTab = function previewTab(aTab, aCallback) {

          
            let currentTab = this.selectedTab;
            try {
              // Suppress focus, ownership and selected tab changes
              this._previewMode = true;
              this.selectedTab = aTab;
              aCallback();
            } finally {
              this.selectedTab = currentTab;
              this._previewMode = false;
            }
          
        
}
console.log: disabletabs: [object XULElement].getBrowserAtIndex = function getBrowserAtIndex(aIndex) {

          
            return this.browsers[aIndex];
          
        
}
console.log: disabletabs: [object XULElement].getBrowserIndexForDocument = function getBrowserIndexForDocument(aDocument) {

          
            var tab = this._getTabForContentWindow(aDocument.defaultView);
            return tab ? tab._tPos : -1;
          
        
}
console.log: disabletabs: [object XULElement].getBrowserForDocument = function getBrowserForDocument(aDocument) {

          
            var tab = this._getTabForContentWindow(aDocument.defaultView);
            return tab ? tab.linkedBrowser : null;
          
        
}
console.log: disabletabs: [object XULElement].getBrowserForContentWindow = function getBrowserForContentWindow(aWindow) {

          
            var tab = this._getTabForContentWindow(aWindow);
            return tab ? tab.linkedBrowser : null;
          
        
}
console.log: disabletabs: [object XULElement].getBrowserForOuterWindowID = function getBrowserForOuterWindowID(aID) {

          
            return this._outerWindowIDBrowserMap.get(aID);
          
        
}
console.log: disabletabs: [object XULElement]._getTabForContentWindow = function _getTabForContentWindow(aWindow) {

        
          // When not using remote browsers, we can take a fast path by getting
          // directly from the content window to the browser without looping
          // over all browsers.
          if (!gMultiProcessBrowser) {
            let browser = aWindow.QueryInterface(Ci.nsIInterfaceRequestor)
                                 .getInterface(Ci.nsIWebNavigation)
                                 .QueryInterface(Ci.nsIDocShell)
                                 .chromeEventHandler;
            return this.getTabForBrowser(browser);
          }

          for (let i = 0; i < this.browsers.length; i++) {
            // NB: We use contentWindowAsCPOW so that this code works both
            // for remote browsers as well. aWindow may be a CPOW.
            if (this.browsers[i].contentWindowAsCPOW == aWindow)
              return this.tabs[i];
          }
          return null;
        
        
}
console.log: disabletabs: [object XULElement]._getTabForBrowser = function _getTabForBrowser(aBrowser) {

        
          let Deprecated = Components.utils.import("resource://gre/modules/Deprecated.jsm", {}).Deprecated;
          let text = "_getTabForBrowser` is now deprecated, please use `getTabForBrowser";
          let url = "https://developer.mozilla.org/docs/Mozilla/Tech/XUL/Method/getTabForBrowser";
          Deprecated.warning(text, url);
          return this.getTabForBrowser(aBrowser);
        
        
}
console.log: disabletabs: [object XULElement].getTabForBrowser = function getTabForBrowser(aBrowser) {

        
          return this._tabForBrowser.get(aBrowser);
        
        
}
console.log: disabletabs: [object XULElement].getNotificationBox = function getNotificationBox(aBrowser) {

          
            return this.getSidebarContainer(aBrowser).parentNode;
          
        
}
console.log: disabletabs: [object XULElement].getSidebarContainer = function getSidebarContainer(aBrowser) {

          
            return this.getBrowserContainer(aBrowser).parentNode;
          
        
}
console.log: disabletabs: [object XULElement].getBrowserContainer = function getBrowserContainer(aBrowser) {

          
            return (aBrowser || this.mCurrentBrowser).parentNode.parentNode;
          
        
}
console.log: disabletabs: [object XULElement].getTabModalPromptBox = function getTabModalPromptBox(aBrowser) {

          
            let browser = (aBrowser || this.mCurrentBrowser);
            if (!browser.tabModalPromptBox) {
              browser.tabModalPromptBox = new TabModalPromptBox(browser);
            }
            return browser.tabModalPromptBox;
          
        
}
console.log: disabletabs: [object XULElement]._callProgressListeners = function _callProgressListeners(aBrowser, aMethod, aArguments, aCallGlobalListeners, aCallTabsListeners) {

          var rv = true;

          function callListeners(listeners, args) {
            for (let p of listeners) {
              if (aMethod in p) {
                try {
                  if (!p[aMethod].apply(p, args))
                    rv = false;
                } catch (e) {
                  // don't inhibit other listeners
                  Components.utils.reportError(e);
                }
              }
            }
          }

          if (!aBrowser)
            aBrowser = this.mCurrentBrowser;

          if (aCallGlobalListeners != false &&
              aBrowser == this.mCurrentBrowser) {
            callListeners(this.mProgressListeners, aArguments);
          }

          if (aCallTabsListeners != false) {
            aArguments.unshift(aBrowser);

            callListeners(this.mTabsProgressListeners, aArguments);
          }

          return rv;
        
}
console.log: disabletabs: [object XULElement].mTabProgressListener = function mTabProgressListener(aTab, aBrowser, aStartsBlank, aWasPreloadedBrowser) {

        
          let stateFlags = 0;
          // Initialize mStateFlags to non-zero e.g. when creating a progress
          // listener for preloaded browsers as there was no progress listener
          // around when the content started loading. If the content didn't
          // quite finish loading yet, mStateFlags will very soon be overridden
          // with the correct value and end up at STATE_STOP again.
          if (aWasPreloadedBrowser) {
            stateFlags = Ci.nsIWebProgressListener.STATE_STOP |
                         Ci.nsIWebProgressListener.STATE_IS_REQUEST;
          }

          return ({
            mTabBrowser: this,
            mTab: aTab,
            mBrowser: aBrowser,
            mBlank: aStartsBlank,

            // cache flags for correct status UI update after tab switching
            mStateFlags: stateFlags,
            mStatus: 0,
            mMessage: "",
            mTotalProgress: 0,

            // count of open requests (should always be 0 or 1)
            mRequestCount: 0,

            destroy: function () {
              delete this.mTab;
              delete this.mBrowser;
              delete this.mTabBrowser;
            },

            _callProgressListeners: function () {
              Array.unshift(arguments, this.mBrowser);
              return this.mTabBrowser._callProgressListeners.apply(this.mTabBrowser, arguments);
            },

            _shouldShowProgress: function (aRequest) {
              if (this.mBlank)
                return false;

              // Don't show progress indicators in tabs for about: URIs
              // pointing to local resources.
              if ((aRequest instanceof Ci.nsIChannel) &&
                  aRequest.originalURI.schemeIs("about") &&
                  (aRequest.URI.schemeIs("jar") || aRequest.URI.schemeIs("file")))
                return false;

              return true;
            },

            onProgressChange: function (aWebProgress, aRequest,
                                        aCurSelfProgress, aMaxSelfProgress,
                                        aCurTotalProgress, aMaxTotalProgress) {
              this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;

              if (!this._shouldShowProgress(aRequest))
                return;

              if (this.mTotalProgress)
                this.mTab.setAttribute("progress", "true");

              this._callProgressListeners("onProgressChange",
                                          [aWebProgress, aRequest,
                                           aCurSelfProgress, aMaxSelfProgress,
                                           aCurTotalProgress, aMaxTotalProgress]);
            },

            onProgressChange64: function (aWebProgress, aRequest,
                                          aCurSelfProgress, aMaxSelfProgress,
                                          aCurTotalProgress, aMaxTotalProgress) {
              return this.onProgressChange(aWebProgress, aRequest,
                aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,
                aMaxTotalProgress);
            },

            onStateChange: function (aWebProgress, aRequest, aStateFlags, aStatus) {
              if (!aRequest)
                return;

              var oldBlank = this.mBlank;

              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
              const nsIChannel = Components.interfaces.nsIChannel;

              if (aStateFlags & nsIWebProgressListener.STATE_START) {
                this.mRequestCount++;
              }
              else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
                const NS_ERROR_UNKNOWN_HOST = 2152398878;
                if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {
                  // to prevent bug 235825: wait for the request handled
                  // by the automatic keyword resolver
                  return;
                }
                // since we (try to) only handle STATE_STOP of the last request,
                // the count of open requests should now be 0
                this.mRequestCount = 0;
              }

              if (aStateFlags & nsIWebProgressListener.STATE_START &&
                  aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
                // It's okay to clear what the user typed when we start
                // loading a document. If the user types, this counter gets
                // set to zero, if the document load ends without an
                // onLocationChange, this counter gets decremented
                // (so we keep it while switching tabs after failed loads)
                // We need to add 2 because loadURIWithFlags may have
                // cancelled a pending load which would have cleared
                // its anchor scroll detection temporary increment.
                if (aWebProgress.isTopLevel) {
                  this.mBrowser.userTypedClear += 2;

                  // If the browser is loading it must not be crashed anymore
                  this.mTab.removeAttribute("crashed");
                }

                if (this._shouldShowProgress(aRequest)) {
                  if (!(aStateFlags & nsIWebProgressListener.STATE_RESTORING)) {
                    this.mTab.setAttribute("busy", "true");
                    if (!(aWebProgress.loadType & Ci.nsIDocShell.LOAD_CMD_RELOAD))
                      this.mTabBrowser.setTabTitleLoading(this.mTab);
                  }

                  if (this.mTab.selected)
                    this.mTabBrowser.mIsBusy = true;
                }
              }
              else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
                       aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {

                if (this.mTab.hasAttribute("busy")) {
                  this.mTab.removeAttribute("busy");
                  this.mTabBrowser._tabAttrModified(this.mTab, ["busy"]);
                  if (!this.mTab.selected)
                    this.mTab.setAttribute("unread", "true");
                }
                this.mTab.removeAttribute("progress");

                if (aWebProgress.isTopLevel) {
                  if (!Components.isSuccessCode(aStatus) &&
                      !isTabEmpty(this.mTab)) {
                    // Restore the current document's location in case the
                    // request was stopped (possibly from a content script)
                    // before the location changed.

                    this.mBrowser.userTypedValue = null;

                    if (this.mTab.selected && gURLBar)
                      URLBarSetURI();
                  } else {
                    // The document is done loading, we no longer want the
                    // value cleared.

                    if (this.mBrowser.userTypedClear > 1)
                      this.mBrowser.userTypedClear -= 2;
                    else if (this.mBrowser.userTypedClear > 0)
                      this.mBrowser.userTypedClear--;
                  }

                  if (!this.mBrowser.mIconURL)
                    this.mTabBrowser.useDefaultIcon(this.mTab);
                }

                if (this.mBlank)
                  this.mBlank = false;

                var location = aRequest.QueryInterface(nsIChannel).URI;

                // For keyword URIs clear the user typed value since they will be changed into real URIs
                if (location.scheme == "keyword")
                  this.mBrowser.userTypedValue = null;

                if (this.mTab.label == this.mTabBrowser.mStringBundle.getString("tabs.connecting"))
                  this.mTabBrowser.setTabTitle(this.mTab);

                if (this.mTab.selected)
                  this.mTabBrowser.mIsBusy = false;
              }

              if (oldBlank) {
                this._callProgressListeners("onUpdateCurrentBrowser",
                                            [aStateFlags, aStatus, "", 0],
                                            true, false);
              } else {
                this._callProgressListeners("onStateChange",
                                            [aWebProgress, aRequest, aStateFlags, aStatus],
                                            true, false);
              }

              this._callProgressListeners("onStateChange",
                                          [aWebProgress, aRequest, aStateFlags, aStatus],
                                          false);

              if (aStateFlags & (nsIWebProgressListener.STATE_START |
                                 nsIWebProgressListener.STATE_STOP)) {
                // reset cached temporary values at beginning and end
                this.mMessage = "";
                this.mTotalProgress = 0;
              }
              this.mStateFlags = aStateFlags;
              this.mStatus = aStatus;
            },

            onLocationChange: function (aWebProgress, aRequest, aLocation,
                                        aFlags) {
              // OnLocationChange is called for both the top-level content
              // and the subframes.
              let topLevel = aWebProgress.isTopLevel;

              if (topLevel) {
                // If userTypedClear > 0, the document loaded correctly and we should be
                // clearing the user typed value. We also need to clear the typed value
                // if the document failed to load, to make sure the urlbar reflects the
                // failed URI (particularly for SSL errors). However, don't clear the value
                // if the error page's URI is about:blank, because that causes complete
                // loss of urlbar contents for invalid URI errors (see bug 867957).
                // Another reason to clear the userTypedValue is if this was an anchor
                // navigation.
                if (this.mBrowser.userTypedClear > 0 ||
                    ((aFlags & Ci.nsIWebProgressListener.LOCATION_CHANGE_ERROR_PAGE) &&
                     aLocation.spec != "about:blank") ||
                     aFlags && Ci.nsIWebProgressListener.LOCATION_CHANGE_SAME_DOCUMENT) {
                  this.mBrowser.userTypedValue = null;
                }

                // If the browser was playing audio, we should remove the playing state.
                if (this.mTab.hasAttribute("soundplaying")) {
                  this.mTab.removeAttribute("soundplaying");
                  this.mTabBrowser._tabAttrModified(this.mTab, ["soundplaying"]);
                }

                // If the browser was previously muted, we should restore the muted state.
                if (this.mTab.hasAttribute("muted")) {
                  this.mTab.linkedBrowser.mute();
                }

                if (this.mTabBrowser.isFindBarInitialized(this.mTab)) {
                  let findBar = this.mTabBrowser.getFindBar(this.mTab);

                  // Close the Find toolbar if we're in old-style TAF mode
                  if (findBar.findMode != findBar.FIND_NORMAL) {
                    findBar.close();
                  }

                  // fix bug 253793 - turn off highlight when page changes
                  findBar.getElement("highlight").checked = false;
                }

                // Don't clear the favicon if this onLocationChange was
                // triggered by a pushState or a replaceState.  See bug 550565.
                if (aWebProgress.isLoadingDocument &&
                    !(aWebProgress.loadType & Ci.nsIDocShell.LOAD_CMD_PUSHSTATE)) {
                  this.mBrowser.mIconURL = null;
                }

                let autocomplete = this.mTabBrowser._placesAutocomplete;
                let unifiedComplete = this.mTabBrowser._unifiedComplete;
                if (this.mBrowser.registeredOpenURI) {
                  autocomplete.unregisterOpenPage(this.mBrowser.registeredOpenURI);
                  unifiedComplete.unregisterOpenPage(this.mBrowser.registeredOpenURI);
                  delete this.mBrowser.registeredOpenURI;
                }
                // Tabs in private windows aren't registered as "Open" so
                // that they don't appear as switch-to-tab candidates.
                if (!isBlankPageURL(aLocation.spec) &&
                    (!PrivateBrowsingUtils.isWindowPrivate(window) ||
                    PrivateBrowsingUtils.permanentPrivateBrowsing)) {
                  autocomplete.registerOpenPage(aLocation);
                  unifiedComplete.registerOpenPage(aLocation);
                  this.mBrowser.registeredOpenURI = aLocation;
                }
              }

              if (!this.mBlank) {
                this._callProgressListeners("onLocationChange",
                                            [aWebProgress, aRequest, aLocation,
                                             aFlags]);
              }

              if (topLevel) {
                this.mBrowser.lastURI = aLocation;
                this.mBrowser.lastLocationChange = Date.now();
              }
            },

            onStatusChange: function (aWebProgress, aRequest, aStatus, aMessage) {
              if (this.mBlank)
                return;

              this._callProgressListeners("onStatusChange",
                                          [aWebProgress, aRequest, aStatus, aMessage]);

              this.mMessage = aMessage;
            },

            onSecurityChange: function (aWebProgress, aRequest, aState) {
              this._callProgressListeners("onSecurityChange",
                                          [aWebProgress, aRequest, aState]);
            },

            onRefreshAttempted: function (aWebProgress, aURI, aDelay, aSameURI) {
              return this._callProgressListeners("onRefreshAttempted",
                                                 [aWebProgress, aURI, aDelay, aSameURI]);
            },

            QueryInterface: function (aIID) {
              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                  aIID.equals(Components.interfaces.nsIWebProgressListener2) ||
                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                  aIID.equals(Components.interfaces.nsISupports))
                return this;
              throw Components.results.NS_NOINTERFACE;
            }
          });
        
        
}
console.log: disabletabs: [object XULElement].setIcon = function setIcon(aTab, aURI) {

          
            var browser = this.getBrowserForTab(aTab);
            browser.mIconURL = aURI instanceof Ci.nsIURI ? aURI.spec : aURI;

            if (aURI && this.mFaviconService) {
              if (!(aURI instanceof Ci.nsIURI))
                aURI = makeURI(aURI);
              this.mFaviconService.setAndFetchFaviconForPage(browser.currentURI,
                                                             aURI, false,
                                                             PrivateBrowsingUtils.isWindowPrivate(window) ?
                                                               this.mFaviconService.FAVICON_LOAD_PRIVATE :
                                                               this.mFaviconService.FAVICON_LOAD_NON_PRIVATE);
            }

            let sizedIconUrl = browser.mIconURL || "";
            if (sizedIconUrl != aTab.getAttribute("image")) {
              if (sizedIconUrl)
                aTab.setAttribute("image", sizedIconUrl);
              else
                aTab.removeAttribute("image");
              this._tabAttrModified(aTab, ["image"]);
            }

            this._callProgressListeners(browser, "onLinkIconAvailable", [browser.mIconURL]);
          
        
}
console.log: disabletabs: [object XULElement].getIcon = function getIcon(aTab) {

          
            let browser = aTab ? this.getBrowserForTab(aTab) : this.selectedBrowser;
            return browser.mIconURL;
          
        
}
console.log: disabletabs: [object XULElement].shouldLoadFavIcon = function shouldLoadFavIcon(aURI) {

          
            return (aURI &&
                    Services.prefs.getBoolPref("browser.chrome.site_icons") &&
                    Services.prefs.getBoolPref("browser.chrome.favicons") &&
                    ("schemeIs" in aURI) && (aURI.schemeIs("http") || aURI.schemeIs("https")));
          
        
}
console.log: disabletabs: [object XULElement].useDefaultIcon = function useDefaultIcon(aTab) {

          
            var browser = this.getBrowserForTab(aTab);
            var documentURI = browser.documentURI;
            var icon = null;

            if (browser.imageDocument) {
              if (Services.prefs.getBoolPref("browser.chrome.site_icons")) {
                let sz = Services.prefs.getIntPref("browser.chrome.image_icons.max_size");
                if (browser.imageDocument.width <= sz &&
                    browser.imageDocument.height <= sz) {
                  icon = browser.currentURI;
                }
              }
            }

            // Use documentURIObject in the check for shouldLoadFavIcon so that we
            // do the right thing with about:-style error pages.  Bug 453442
            if (!icon && this.shouldLoadFavIcon(documentURI)) {
              let url = documentURI.prePath + "/favicon.ico";
              if (!this.isFailedIcon(url))
                icon = url;
            }
            this.setIcon(aTab, icon);
          
        
}
console.log: disabletabs: [object XULElement].isFailedIcon = function isFailedIcon(aURI) {

          
            if (this.mFaviconService) {
              if (!(aURI instanceof Ci.nsIURI))
                aURI = makeURI(aURI);
              return this.mFaviconService.isFailedFavicon(aURI);
            }
            return null;
          
        
}
console.log: disabletabs: [object XULElement].getWindowTitleForBrowser = function getWindowTitleForBrowser(aBrowser) {

          
            var newTitle = "";
            var docElement = this.ownerDocument.documentElement;
            var sep = docElement.getAttribute("titlemenuseparator");

            // Strip out any null bytes in the content title, since the
            // underlying widget implementations of nsWindow::SetTitle pass
            // null-terminated strings to system APIs.
            var docTitle = aBrowser.contentTitle.replace(/\0/g, "");

            if (!docTitle)
              docTitle = docElement.getAttribute("titledefault");

            var modifier = docElement.getAttribute("titlemodifier");
            if (docTitle) {
              newTitle += docElement.getAttribute("titlepreface");
              newTitle += docTitle;
              if (modifier)
                newTitle += sep;
            }
            newTitle += modifier;

            // If location bar is hidden and the URL type supports a host,
            // add the scheme and host to the title to prevent spoofing.
            // XXX https://bugzilla.mozilla.org/show_bug.cgi?id=22183#c239
            try {
              if (docElement.getAttribute("chromehidden").includes("location")) {
                var uri = this.mURIFixup.createExposableURI(
                            aBrowser.currentURI);
                if (uri.scheme == "about")
                  newTitle = uri.spec + sep + newTitle;
                else
                  newTitle = uri.prePath + sep + newTitle;
              }
            } catch (e) {}

            return newTitle;
          
        
}
console.log: disabletabs: [object XULElement].updateTitlebar = function updateTitlebar() {

          
            if ("TabView" in window && TabView.isVisible()) {
              // ToDo: this will be removed when we gain ability to draw to the menu bar.
              // Bug 586175
              this.ownerDocument.title = TabView.windowTitle;
            }
            else {
              this.ownerDocument.title = this.getWindowTitleForBrowser(this.mCurrentBrowser);
            }
          
        
}
console.log: disabletabs: [object XULElement].updateCurrentBrowser = function updateCurrentBrowser(aForceUpdate) {

          
            var newBrowser = this.getBrowserAtIndex(this.tabContainer.selectedIndex);
            if (this.mCurrentBrowser == newBrowser && !aForceUpdate)
              return;

            if (!aForceUpdate) {
              TelemetryStopwatch.start("FX_TAB_SWITCH_UPDATE_MS");
              if (!Services.appinfo.browserTabsRemoteAutostart) {
                // old way of measuring tab paint which is not
                // valid with e10s.
                window.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDOMWindowUtils)
                                                               .beginTabSwitch();
              }
            }

            var oldTab = this.mCurrentTab;

            // Preview mode should not reset the owner
            if (!this._previewMode && !oldTab.selected)
              oldTab.owner = null;

            if (this._lastRelatedTab) {
              if (!this._lastRelatedTab.selected)
                this._lastRelatedTab.owner = null;
              this._lastRelatedTab = null;
            }

            var oldBrowser = this.mCurrentBrowser;

            if (!gMultiProcessBrowser) {
              oldBrowser.setAttribute("type", "content-targetable");
              oldBrowser.docShellIsActive = false;
              newBrowser.setAttribute("type", "content-primary");
              newBrowser.docShellIsActive =
                (window.windowState != window.STATE_MINIMIZED);
            }

            var updateBlockedPopups = false;
            if ((oldBrowser.blockedPopups && !newBrowser.blockedPopups) ||
                (!oldBrowser.blockedPopups && newBrowser.blockedPopups))
              updateBlockedPopups = true;

            this.mCurrentBrowser = newBrowser;
            this.mCurrentTab = this.tabContainer.selectedItem;
            this.showTab(this.mCurrentTab);

            var forwardButtonContainer = document.getElementById("urlbar-wrapper");
            if (forwardButtonContainer) {
              forwardButtonContainer.setAttribute("switchingtabs", "true");
              window.addEventListener("MozAfterPaint", function removeSwitchingtabsAttr() {
                window.removeEventListener("MozAfterPaint", removeSwitchingtabsAttr);
                forwardButtonContainer.removeAttribute("switchingtabs");
              });
            }

            this._appendStatusPanel();

            if (updateBlockedPopups)
              this.mCurrentBrowser.updateBlockedPopups();

            // Update the URL bar.
            var loc = this.mCurrentBrowser.currentURI;

            var webProgress = this.mCurrentBrowser.webProgress;
            var securityUI = this.mCurrentBrowser.securityUI;

            this._callProgressListeners(null, "onLocationChange",
                                        [webProgress, null, loc, 0], true,
                                        false);

            if (securityUI) {
              // Include the true final argument to indicate that this event is
              // simulated (instead of being observed by the webProgressListener).
              this._callProgressListeners(null, "onSecurityChange",
                                          [webProgress, null, securityUI.state, true],
                                          true, false);
            }

            var listener = this.mTabListeners[this.tabContainer.selectedIndex] || null;
            if (listener && listener.mStateFlags) {
              this._callProgressListeners(null, "onUpdateCurrentBrowser",
                                          [listener.mStateFlags, listener.mStatus,
                                           listener.mMessage, listener.mTotalProgress],
                                          true, false);
            }

            if (!this._previewMode) {
              this.mCurrentTab.lastAccessed = Infinity;
              this.mCurrentTab.removeAttribute("unread");
              oldTab.lastAccessed = Date.now();

              let oldFindBar = oldTab._findBar;
              if (oldFindBar &&
                  oldFindBar.findMode == oldFindBar.FIND_NORMAL &&
                  !oldFindBar.hidden)
                this._lastFindValue = oldFindBar._findField.value;

              this.updateTitlebar();

              this.mCurrentTab.removeAttribute("titlechanged");
              this.mCurrentTab.removeAttribute("attention");
            }

            // If the new tab is busy, and our current state is not busy, then
            // we need to fire a start to all progress listeners.
            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
            if (this.mCurrentTab.hasAttribute("busy") && !this.mIsBusy) {
              this.mIsBusy = true;
              this._callProgressListeners(null, "onStateChange",
                                          [webProgress, null,
                                           nsIWebProgressListener.STATE_START |
                                           nsIWebProgressListener.STATE_IS_NETWORK, 0],
                                          true, false);
            }

            // If the new tab is not busy, and our current state is busy, then
            // we need to fire a stop to all progress listeners.
            if (!this.mCurrentTab.hasAttribute("busy") && this.mIsBusy) {
              this.mIsBusy = false;
              this._callProgressListeners(null, "onStateChange",
                                          [webProgress, null,
                                           nsIWebProgressListener.STATE_STOP |
                                           nsIWebProgressListener.STATE_IS_NETWORK, 0],
                                          true, false);
            }

            this._setCloseKeyState(!this.mCurrentTab.pinned);

            // TabSelect events are suppressed during preview mode to avoid confusing extensions and other bits of code
            // that might rely upon the other changes suppressed.
            // Focus is suppressed in the event that the main browser window is minimized - focusing a tab would restore the window
            if (!this._previewMode) {
              // We've selected the new tab, so go ahead and notify listeners.
              let event = new CustomEvent("TabSelect", {
                bubbles: true,
                cancelable: false,
                detail: {
                  previousTab: oldTab
                }
              });
              this.mCurrentTab.dispatchEvent(event);

              this._tabAttrModified(oldTab, ["selected"]);
              this._tabAttrModified(this.mCurrentTab, ["selected"]);

              if (oldBrowser != newBrowser &&
                  oldBrowser.docShell &&
                  oldBrowser.docShell.contentViewer.inPermitUnload) {
                // Since the user is switching away from a tab that has
                // a beforeunload prompt active, we remove the prompt.
                // This prevents confusing user flows like the following:
                //   1. User attempts to close Firefox
                //   2. User switches tabs (ingoring a beforeunload prompt)
                //   3. User returns to tab, presses "Leave page"
                let promptBox = this.getTabModalPromptBox(oldBrowser);
                let prompts = promptBox.listPrompts();
                // There might not be any prompts here if the tab was closed
                // while in an onbeforeunload prompt, which will have
                // destroyed aforementioned prompt already, so check there's
                // something to remove, first:
                if (prompts.length) {
                  // NB: This code assumes that the beforeunload prompt
                  //     is the top-most prompt on the tab.
                  prompts[prompts.length - 1].abortPrompt();
                }
              }

              oldBrowser._urlbarFocused = (gURLBar && gURLBar.focused);
              if (this.isFindBarInitialized(oldTab)) {
                let findBar = this.getFindBar(oldTab);
                oldTab._findBarFocused = (!findBar.hidden &&
                  findBar._findField.getAttribute("focused") == "true");
              }

              // If focus is in the tab bar, retain it there.
              if (document.activeElement == oldTab) {
                // We need to explicitly focus the new tab, because
                // tabbox.xml does this only in some cases.
                this.mCurrentTab.focus();
              } else if (gMultiProcessBrowser && document.activeElement !== newBrowser) {
                // Clear focus so that _adjustFocusAfterTabSwitch can detect if
                // some element has been focused and respect that.
                document.activeElement.blur();
              }

              if (!gMultiProcessBrowser)
                this._adjustFocusAfterTabSwitch(this.mCurrentTab);
            }

            updateUserContextUIIndicator(gBrowser.selectedBrowser);

            this.tabContainer._setPositionalAttributes();

            if (!gMultiProcessBrowser) {
              let event = new CustomEvent("TabSwitchDone", {
                bubbles: true,
                cancelable: true
              });
              this.dispatchEvent(event);
            }

            if (!aForceUpdate)
              TelemetryStopwatch.finish("FX_TAB_SWITCH_UPDATE_MS");
          
        
}
console.log: disabletabs: [object XULElement]._adjustFocusAfterTabSwitch = function _adjustFocusAfterTabSwitch(newTab) {

        // Don't steal focus from the tab bar.
        if (document.activeElement == newTab)
          return;

        let newBrowser = this.getBrowserForTab(newTab);

        // If there's a tabmodal prompt showing, focus it.
        if (newBrowser.hasAttribute("tabmodalPromptShowing")) {
          let XUL_NS = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
          let prompts = newBrowser.parentNode.getElementsByTagNameNS(XUL_NS, "tabmodalprompt");
          let prompt = prompts[prompts.length - 1];
          prompt.Dialog.setDefaultFocus();
          return;
        }

        // Focus the location bar if it was previously focused for that tab.
        // In full screen mode, only bother making the location bar visible
        // if the tab is a blank one.
        if (newBrowser._urlbarFocused && gURLBar) {
          // Explicitly close the popup if the URL bar retains focus
          gURLBar.closePopup();

          if (!window.fullScreen) {
            gURLBar.focus();
            return;
          }

          if (isTabEmpty(this.mCurrentTab)) {
            focusAndSelectUrlBar();
            return;
          }
        }

        // Focus the find bar if it was previously focused for that tab.
        if (gFindBarInitialized && !gFindBar.hidden &&
            this.selectedTab._findBarFocused) {
          gFindBar._findField.focus();
          return;
        }

        // Don't focus the content area if something has been focused after the
        // tab switch was initiated.
        if (gMultiProcessBrowser &&
            document.activeElement != document.documentElement)
          return;

        // We're now committed to focusing the content area.
        let fm = Services.focus;
        let focusFlags = fm.FLAG_NOSCROLL;

        if (!gMultiProcessBrowser) {
          let newFocusedElement = fm.getFocusedElementForWindow(window.content, true, {});

          // for anchors, use FLAG_SHOWRING so that it is clear what link was
          // last clicked when switching back to that tab
          if (newFocusedElement &&
              (newFocusedElement instanceof HTMLAnchorElement ||
               newFocusedElement.getAttributeNS("http://www.w3.org/1999/xlink", "type") == "simple"))
            focusFlags |= fm.FLAG_SHOWRING;
        }

        fm.setFocus(newBrowser, focusFlags);
        
}
console.log: disabletabs: [object XULElement]._tabAttrModified = function _tabAttrModified(aTab, aChanged) {

          if (aTab.closing)
            return;

          let event = new CustomEvent("TabAttrModified", {
            bubbles: true,
            cancelable: false,
            detail: {
              changed: aChanged,
            }
          });
          aTab.dispatchEvent(event);
        
}
console.log: disabletabs: [object XULElement].setTabTitleLoading = function setTabTitleLoading(aTab) {

          
            aTab.label = this.mStringBundle.getString("tabs.connecting");
            aTab.crop = "end";
            this._tabAttrModified(aTab, ["label", "crop"]);
          
        
}
console.log: disabletabs: [object XULElement].setTabTitle = function setTabTitle(aTab) {

          
            var browser = this.getBrowserForTab(aTab);
            var crop = "end";
            var title = browser.contentTitle;

            if (!title) {
              if (browser.currentURI.spec) {
                try {
                  title = this.mURIFixup.createExposableURI(browser.currentURI).spec;
                } catch(ex) {
                  title = browser.currentURI.spec;
                }
              }

              if (title && !isBlankPageURL(title)) {
                // At this point, we now have a URI.
                // Let's try to unescape it using a character set
                // in case the URI is not ASCII.
                try {
                  var characterSet = browser.characterSet;
                  const textToSubURI = Components.classes["@mozilla.org/intl/texttosuburi;1"]
                                                 .getService(Components.interfaces.nsITextToSubURI);
                  title = textToSubURI.unEscapeNonAsciiURI(characterSet, title);
                } catch(ex) { /* Do nothing. */ }

                crop = "center";

              } else // Still no title?  Fall back to our untitled string.
                title = this.mStringBundle.getString("tabs.emptyTabTitle");
            }

            if (aTab.label == title &&
                aTab.crop == crop)
              return false;

            aTab.label = title;
            aTab.crop = crop;
            this._tabAttrModified(aTab, ["label", "crop"]);

            if (aTab.selected)
              this.updateTitlebar();

            return true;
          
        
}
console.log: disabletabs: [object XULElement].loadOneTab = function loadOneTab(aURI, aReferrerURI, aCharset, aPostData, aLoadInBackground, aAllowThirdPartyFixup) {

          
            var aReferrerPolicy;
            var aFromExternal;
            var aRelatedToCurrent;
            var aAllowMixedContent;
            var aSkipAnimation;
            var aForceNotRemote;
            var aNoReferrer;
            var aUserContextId;
            if (arguments.length == 2 &&
                typeof arguments[1] == "object" &&
                !(arguments[1] instanceof Ci.nsIURI)) {
              let params = arguments[1];
              aReferrerURI          = params.referrerURI;
              aReferrerPolicy       = params.referrerPolicy;
              aCharset              = params.charset;
              aPostData             = params.postData;
              aLoadInBackground     = params.inBackground;
              aAllowThirdPartyFixup = params.allowThirdPartyFixup;
              aFromExternal         = params.fromExternal;
              aRelatedToCurrent     = params.relatedToCurrent;
              aAllowMixedContent    = params.allowMixedContent;
              aSkipAnimation        = params.skipAnimation;
              aForceNotRemote       = params.forceNotRemote;
              aNoReferrer           = params.noReferrer;
              aUserContextId        = params.userContextId;
            }

            var bgLoad = (aLoadInBackground != null) ? aLoadInBackground :
                         Services.prefs.getBoolPref("browser.tabs.loadInBackground");
            var owner = bgLoad ? null : this.selectedTab;
            var tab = this.addTab(aURI, {
                                  referrerURI: aReferrerURI,
                                  referrerPolicy: aReferrerPolicy,
                                  charset: aCharset,
                                  postData: aPostData,
                                  ownerTab: owner,
                                  allowThirdPartyFixup: aAllowThirdPartyFixup,
                                  fromExternal: aFromExternal,
                                  relatedToCurrent: aRelatedToCurrent,
                                  skipAnimation: aSkipAnimation,
                                  allowMixedContent: aAllowMixedContent,
                                  forceNotRemote: aForceNotRemote,
                                  noReferrer: aNoReferrer,
                                  userContextId: aUserContextId });
            if (!bgLoad)
              this.selectedTab = tab;

            return tab;
         
        
}
console.log: disabletabs: [object XULElement].loadTabs = function loadTabs(aURIs, aLoadInBackground, aReplace) {

          if (!aURIs.length)
            return;

          // The tab selected after this new tab is closed (i.e. the new tab's
          // "owner") is the next adjacent tab (i.e. not the previously viewed tab)
          // when several urls are opened here (i.e. closing the first should select
          // the next of many URLs opened) or if the pref to have UI links opened in
          // the background is set (i.e. the link is not being opened modally)
          //
          // i.e.
          //    Number of URLs    Load UI Links in BG       Focus Last Viewed?
          //    == 1              false                     YES
          //    == 1              true                      NO
          //    > 1               false/true                NO
          var multiple = aURIs.length > 1;
          var owner = multiple || aLoadInBackground ? null : this.selectedTab;
          var firstTabAdded = null;

          if (aReplace) {
            try {
              this.loadURI(aURIs[0], null, null);
            } catch (e) {
              // Ignore failure in case a URI is wrong, so we can continue
              // opening the next ones.
            }
          }
          else
            firstTabAdded = this.addTab(aURIs[0], {ownerTab: owner, skipAnimation: multiple});

          var tabNum = this.tabContainer.selectedIndex;
          for (let i = 1; i < aURIs.length; ++i) {
            let tab = this.addTab(aURIs[i], {skipAnimation: true});
            if (aReplace)
              this.moveTabTo(tab, ++tabNum);
          }

          if (!aLoadInBackground) {
            if (firstTabAdded) {
              // .selectedTab setter focuses the content area
              this.selectedTab = firstTabAdded;
            }
            else
              this.selectedBrowser.focus();
          }
        
}
console.log: disabletabs: [object XULElement].updateBrowserRemoteness = function updateBrowserRemoteness(aBrowser, aShouldBeRemote) {

          
            let isRemote = aBrowser.getAttribute("remote") == "true";
            if (isRemote == aShouldBeRemote)
              return false;

            let wasActive = document.activeElement == aBrowser;

            // Unmap the old outerWindowID.
            this._outerWindowIDBrowserMap.delete(aBrowser.outerWindowID);

            // Unhook our progress listener.
            let tab = this.getTabForBrowser(aBrowser);
            let index = tab._tPos;
            let filter = this.mTabFilters[index];
            aBrowser.webProgress.removeProgressListener(filter);
            // Make sure the browser is destroyed so it unregisters from observer notifications
            aBrowser.destroy();

            // Make sure to restore the original droppedLinkHandler.
            let droppedLinkHandler = aBrowser.droppedLinkHandler;

            // Change the "remote" attribute.
            let parent = aBrowser.parentNode;
            parent.removeChild(aBrowser);
            aBrowser.setAttribute("remote", aShouldBeRemote ? "true" : "false");
            parent.appendChild(aBrowser);

            aBrowser.droppedLinkHandler = droppedLinkHandler;

            // Switching a browser's remoteness will create a new frameLoader.
            // As frameLoaders start out with an active docShell we have to
            // deactivate it if this is not the selected tab's browser or the
            // browser window is minimized.
            aBrowser.docShellIsActive = (aBrowser == this.selectedBrowser &&
                                         window.windowState != window.STATE_MINIMIZED);

            // Restore the progress listener.
            aBrowser.webProgress.addProgressListener(filter, Ci.nsIWebProgress.NOTIFY_ALL);

            // Restore the securityUI state.
            let securityUI = aBrowser.securityUI;
            let state = securityUI ? securityUI.state
                                   : Ci.nsIWebProgressListener.STATE_IS_INSECURE;
            // Include the true final argument to indicate that this event is
            // simulated (instead of being observed by the webProgressListener).
            this._callProgressListeners(aBrowser, "onSecurityChange",
                                        [aBrowser.webProgress, null, securityUI.state, true],
                                        true, false);

            if (aShouldBeRemote) {
              // Switching the browser to be remote will connect to a new child
              // process so the browser can no longer be considered to be
              // crashed.
              tab.removeAttribute("crashed");
            } else {
              aBrowser.messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: tab.pinned })

              // Register the new outerWindowID.
              this._outerWindowIDBrowserMap.set(aBrowser.outerWindowID, aBrowser);
            }

            if (wasActive)
              aBrowser.focus();

            // If the findbar has been initialised, reset its browser reference.
            if (this.isFindBarInitialized(tab)) {
              this.getFindBar(tab).browser = aBrowser;
            }

            let evt = document.createEvent("Events");
            evt.initEvent("TabRemotenessChange", true, false);
            tab.dispatchEvent(evt);

            return true;
          
        
}
console.log: disabletabs: [object XULElement].updateBrowserRemotenessByURL = function updateBrowserRemotenessByURL(aBrowser, aURL) {

          
            if (!gMultiProcessBrowser)
              return this.updateBrowserRemoteness(aBrowser, false);

            let process = aBrowser.isRemoteBrowser ? Ci.nsIXULRuntime.PROCESS_TYPE_CONTENT
                                                   : Ci.nsIXULRuntime.PROCESS_TYPE_DEFAULT;

            // If this URL can't load in the browser's current process then flip
            // it to the other process
            if (!E10SUtils.canLoadURIInProcess(aURL, process))
              return this.updateBrowserRemoteness(aBrowser, !aBrowser.isRemoteBrowser);

            return false;
          
        
}
console.log: disabletabs: [object XULElement]._getPreloadedBrowser = function _getPreloadedBrowser() {

          
            if (!this._isPreloadingEnabled()) {
              return null;
            }

            // The preloaded browser might be null.
            let browser = this._preloadedBrowser;

            // Consume the browser.
            this._preloadedBrowser = null;

            // Attach the nsIFormFillController now that we know the browser
            // will be used. If we do that before and the preloaded browser
            // won't be consumed until shutdown then we leak a docShell.
            // Also, we do not need to take care of attaching nsIFormFillControllers
            // in the case that the browser is remote, as remote browsers take
            // care of that themselves.
            if (browser &&
                this.hasAttribute("autocompletepopup") &&
                !browser.isRemoteBrowser) {
              browser.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));
              browser.attachFormFill();
            }

            return browser;
          
        
}
console.log: disabletabs: [object XULElement]._isPreloadingEnabled = function _isPreloadingEnabled() {

          
            // Preloading for the newtab page is enabled when the pref is true
            // and the URL is "about:newtab". We do not support preloading for
            // custom newtab URLs.
            return Services.prefs.getBoolPref("browser.newtab.preload") &&
                   !aboutNewTabService.overridden;
          
        
}
console.log: disabletabs: [object XULElement]._createPreloadBrowser = function _createPreloadBrowser() {

          
            // Do nothing if we have a preloaded browser already
            // or preloading of newtab pages is disabled.
            if (this._preloadedBrowser || !this._isPreloadingEnabled()) {
              return;
            }

            let remote = gMultiProcessBrowser &&
                         E10SUtils.canLoadURIInProcess(BROWSER_NEW_TAB_URL, Ci.nsIXULRuntime.PROCESS_TYPE_CONTENT);
            let browser = this._createBrowser({isPreloadBrowser: true, remote: remote});
            this._preloadedBrowser = browser;

            let notificationbox = this.getNotificationBox(browser);
            this.mPanelContainer.appendChild(notificationbox);

            if (remote) {
              // For remote browsers, we need to make sure that the webProgress is
              // instantiated, otherwise the parent won't get informed about the state
              // of the preloaded browser until it gets attached to a tab.
              browser.webProgress;
            }

            browser.loadURI(BROWSER_NEW_TAB_URL);
            browser.docShellIsActive = false;
          
        
}
console.log: disabletabs: [object XULElement]._createBrowser = function _createBrowser(aParams) {

          
            const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";

            let remote = aParams && aParams.remote;
            let uriIsAboutBlank = aParams && aParams.uriIsAboutBlank;
            let isPreloadBrowser = aParams && aParams.isPreloadBrowser;
            let userContextId = aParams && aParams.userContextId;

            let b = document.createElementNS(NS_XUL, "browser");
            b.permanentKey = {};
            b.setAttribute("type", "content-targetable");
            b.setAttribute("message", "true");
            b.setAttribute("messagemanagergroup", "browsers");
            b.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
            b.setAttribute("tooltip", this.getAttribute("contenttooltip"));

            if (userContextId)
              b.setAttribute("usercontextid", userContextId);

            if (remote)
              b.setAttribute("remote", "true");

            if (window.gShowPageResizers && window.windowState == window.STATE_NORMAL) {
              b.setAttribute("showresizer", "true");
            }

            if (!isPreloadBrowser && this.hasAttribute("autocompletepopup"))
              b.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));

            if (this.hasAttribute("selectmenulist"))
              b.setAttribute("selectmenulist", this.getAttribute("selectmenulist"));

            b.setAttribute("autoscrollpopup", this._autoScrollPopup.id);

            // Create the browserStack container
            var stack = document.createElementNS(NS_XUL, "stack");
            stack.className = "browserStack";
            stack.appendChild(b);
            stack.setAttribute("flex", "1");

            // Create the browserContainer
            var browserContainer = document.createElementNS(NS_XUL, "vbox");
            browserContainer.className = "browserContainer";
            browserContainer.appendChild(stack);
            browserContainer.setAttribute("flex", "1");

            // Create the sidebar container
            var browserSidebarContainer = document.createElementNS(NS_XUL,
                                                                   "hbox");
            browserSidebarContainer.className = "browserSidebarContainer";
            browserSidebarContainer.appendChild(browserContainer);
            browserSidebarContainer.setAttribute("flex", "1");

            // Add the Message and the Browser to the box
            var notificationbox = document.createElementNS(NS_XUL,
                                                           "notificationbox");
            notificationbox.setAttribute("flex", "1");
            notificationbox.setAttribute("notificationside", "top");
            notificationbox.appendChild(browserSidebarContainer);

            // Prevent the superfluous initial load of a blank document
            // if we're going to load something other than about:blank.
            if (!uriIsAboutBlank) {
              b.setAttribute("nodefaultsrc", "true");
            }

            return b;
          
        
}
console.log: disabletabs: [object XULElement].addTab = function addTab(aURI, aReferrerURI, aCharset, aPostData, aOwner, aAllowThirdPartyFixup) {

          
            const NS_XUL = "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul";
            var aReferrerPolicy;
            var aFromExternal;
            var aRelatedToCurrent;
            var aSkipAnimation;
            var aAllowMixedContent;
            var aForceNotRemote;
            var aNoReferrer;
            var aUserContextId;
            if (arguments.length == 2 &&
                typeof arguments[1] == "object" &&
                !(arguments[1] instanceof Ci.nsIURI)) {
              let params = arguments[1];
              aReferrerURI          = params.referrerURI;
              aReferrerPolicy       = params.referrerPolicy;
              aCharset              = params.charset;
              aPostData             = params.postData;
              aOwner                = params.ownerTab;
              aAllowThirdPartyFixup = params.allowThirdPartyFixup;
              aFromExternal         = params.fromExternal;
              aRelatedToCurrent     = params.relatedToCurrent;
              aSkipAnimation        = params.skipAnimation;
              aAllowMixedContent    = params.allowMixedContent;
              aForceNotRemote       = params.forceNotRemote;
              aNoReferrer           = params.noReferrer;
              aUserContextId        = params.userContextId;
            }

            // if we're adding tabs, we're past interrupt mode, ditch the owner
            if (this.mCurrentTab.owner)
              this.mCurrentTab.owner = null;

            var t = document.createElementNS(NS_XUL, "tab");

            var uriIsAboutBlank = !aURI || aURI == "about:blank";

            if (aUserContextId)
              t.setAttribute("usercontextid", aUserContextId);
            t.setAttribute("crop", "end");
            t.setAttribute("onerror", "this.removeAttribute('image');");
            t.className = "tabbrowser-tab";

            // The new browser should be remote if this is an e10s window and
            // the uri to load can be loaded remotely.
            let remote = gMultiProcessBrowser &&
                         !aForceNotRemote &&
                         E10SUtils.canLoadURIInProcess(aURI, Ci.nsIXULRuntime.PROCESS_TYPE_CONTENT);

            this.tabContainer._unlockTabSizing();

            // When overflowing, new tabs are scrolled into view smoothly, which
            // doesn't go well together with the width transition. So we skip the
            // transition in that case.
            let animate = !aSkipAnimation &&
                          this.tabContainer.getAttribute("overflow") != "true" &&
                          Services.prefs.getBoolPref("browser.tabs.animate");
            if (!animate) {
              t.setAttribute("fadein", "true");
              setTimeout(function (tabContainer) {
                tabContainer._handleNewTab(t);
              }, 0, this.tabContainer);
            }

            // invalidate caches
            this._browsers = null;
            this._visibleTabs = null;

            this.tabContainer.appendChild(t);

            // If this new tab is owned by another, assert that relationship
            if (aOwner)
              t.owner = aOwner;

            let b;
            let usingPreloadedContent = false;

            // If we open a new tab with the newtab URL in the default
            // userContext, check if there is a preloaded browser ready.
            // Private windows are not included because both the label and the
            // icon for the tab would be set incorrectly (see bug 1195981).
            if (aURI == BROWSER_NEW_TAB_URL && !aUserContextId &&
                !PrivateBrowsingUtils.isWindowPrivate(window)) {
              b = this._getPreloadedBrowser();
              usingPreloadedContent = !!b;
            }

            if (!b) {
              // No preloaded browser found, create one.
              b = this._createBrowser({remote: remote,
                                       uriIsAboutBlank: uriIsAboutBlank,
                                       userContextId: aUserContextId});
            }

            let notificationbox = this.getNotificationBox(b);
            var position = this.tabs.length - 1;
            var uniqueId = this._generateUniquePanelID();
            notificationbox.id = uniqueId;
            t.linkedPanel = uniqueId;
            t.linkedBrowser = b;
            this._tabForBrowser.set(b, t);
            t._tPos = position;
            t.lastAccessed = Date.now();
            this.tabContainer._setPositionalAttributes();

            // Inject the <browser> into the DOM if necessary.
            if (!notificationbox.parentNode) {
              // NB: this appendChild call causes us to run constructors for the
              // browser element, which fires off a bunch of notifications. Some
              // of those notifications can cause code to run that inspects our
              // state, so it is important that the tab element is fully
              // initialized by this point.
              this.mPanelContainer.appendChild(notificationbox);
            }

            // We've waited until the tab is in the DOM to set the label. This
            // allows the TabLabelModified event to be properly dispatched.
            if (!aURI || isBlankPageURL(aURI)) {
              t.label = this.mStringBundle.getString("tabs.emptyTabTitle");
            } else if (aURI.toLowerCase().startsWith("javascript:")) {
              // This can go away when bug 672618 or bug 55696 are fixed.
              t.label = aURI;
            }

            this.tabContainer.updateVisibility();

            // wire up a progress listener for the new browser object.
            var tabListener = this.mTabProgressListener(t, b, uriIsAboutBlank, usingPreloadedContent);
            const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                                     .createInstance(Components.interfaces.nsIWebProgress);
            filter.addProgressListener(tabListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
            b.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
            this.mTabListeners[position] = tabListener;
            this.mTabFilters[position] = filter;

            b.droppedLinkHandler = handleDroppedLink;

            // Swap in a preloaded customize tab, if available.
            if (aURI == "about:customizing") {
              usingPreloadedContent = gCustomizationTabPreloader.newTab(t);
            }

            // Dispatch a new tab notification.  We do this once we're
            // entirely done, so that things are in a consistent state
            // even if the event listener opens or closes tabs.
            var evt = document.createEvent("Events");
            evt.initEvent("TabOpen", true, false);
            t.dispatchEvent(evt);

            // If we didn't swap docShells with a preloaded browser
            // then let's just continue loading the page normally.
            if (!usingPreloadedContent && !uriIsAboutBlank) {
              // pretend the user typed this so it'll be available till
              // the document successfully loads
              if (aURI && gInitialPages.indexOf(aURI) == -1)
                b.userTypedValue = aURI;

              let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;
              if (aAllowThirdPartyFixup) {
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP;
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FIXUP_SCHEME_TYPOS;
              }
              if (aFromExternal)
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_FROM_EXTERNAL;
              if (aAllowMixedContent)
                flags |= Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_MIXED_CONTENT;
              try {
                b.loadURIWithFlags(aURI, {
                                   flags: flags,
                                   referrerURI: aNoReferrer ? null: aReferrerURI,
                                   referrerPolicy: aReferrerPolicy,
                                   charset: aCharset,
                                   postData: aPostData,
                                   });
              } catch (ex) {
                Cu.reportError(ex);
              }
            }

            // We start our browsers out as inactive, and then maintain
            // activeness in the tab switcher.
            b.docShellIsActive = false;

            // When addTab() is called with an URL that is not "about:blank" we
            // set the "nodefaultsrc" attribute that prevents a frameLoader
            // from being created as soon as the linked <browser> is inserted
            // into the DOM. We thus have to register the new outerWindowID
            // for non-remote browsers after we have called browser.loadURI().
            //
            // Note: Only do this of we still have a docShell. The TabOpen
            // event was dispatched above and a gBrowser.removeTab() call from
            // one of its listeners could cause us to fail here.
            if (!remote && b.docShell) {
              this._outerWindowIDBrowserMap.set(b.outerWindowID, b);
            }

            // Check if we're opening a tab related to the current tab and
            // move it to after the current tab.
            // aReferrerURI is null or undefined if the tab is opened from
            // an external application or bookmark, i.e. somewhere other
            // than the current tab.
            if ((aRelatedToCurrent == null ? aReferrerURI : aRelatedToCurrent) &&
                Services.prefs.getBoolPref("browser.tabs.insertRelatedAfterCurrent")) {
              let newTabPos = (this._lastRelatedTab ||
                               this.selectedTab)._tPos + 1;
              if (this._lastRelatedTab)
                this._lastRelatedTab.owner = null;
              else
                t.owner = this.selectedTab;
              this.moveTabTo(t, newTabPos);
              this._lastRelatedTab = t;
            }

            if (animate) {
              requestAnimationFrame(function () {
                this.tabContainer._handleTabTelemetryStart(t, aURI);

                // kick the animation off
                t.setAttribute("fadein", "true");
              }.bind(this));
            }

            return t;
          
        
}
console.log: disabletabs: [object XULElement].warnAboutClosingTabs = function warnAboutClosingTabs(aCloseTabs, aTab) {

        
          var tabsToClose;
          switch (aCloseTabs) {
            case this.closingTabsEnum.ALL:
              tabsToClose = this.tabs.length - this._removingTabs.length -
                            gBrowser._numPinnedTabs;
              break;
            case this.closingTabsEnum.OTHER:
              tabsToClose = this.visibleTabs.length - 1 - gBrowser._numPinnedTabs;
              break;
            case this.closingTabsEnum.TO_END:
              if (!aTab)
                throw new Error("Required argument missing: aTab");

              tabsToClose = this.getTabsToTheEndFrom(aTab).length;
              break;
            default:
              throw new Error("Invalid argument: " + aCloseTabs);
          }

          if (tabsToClose <= 1)
            return true;

          const pref = aCloseTabs == this.closingTabsEnum.ALL ?
                       "browser.tabs.warnOnClose" : "browser.tabs.warnOnCloseOtherTabs";
          var shouldPrompt = Services.prefs.getBoolPref(pref);
          if (!shouldPrompt)
            return true;

          var ps = Services.prompt;

          // default to true: if it were false, we wouldn't get this far
          var warnOnClose = { value: true };
          var bundle = this.mStringBundle;

          // focus the window before prompting.
          // this will raise any minimized window, which will
          // make it obvious which window the prompt is for and will
          // solve the problem of windows "obscuring" the prompt.
          // see bug #350299 for more details
          window.focus();
          var warningMessage =
            PluralForm.get(tabsToClose, bundle.getString("tabs.closeWarningMultiple"))
                      .replace("#1", tabsToClose);
          var buttonPressed =
            ps.confirmEx(window,
                         bundle.getString("tabs.closeWarningTitle"),
                         warningMessage,
                         (ps.BUTTON_TITLE_IS_STRING * ps.BUTTON_POS_0)
                         + (ps.BUTTON_TITLE_CANCEL * ps.BUTTON_POS_1),
                         bundle.getString("tabs.closeButtonMultiple"),
                         null, null,
                         aCloseTabs == this.closingTabsEnum.ALL ?
                           bundle.getString("tabs.closeWarningPromptMe") : null,
                         warnOnClose);
          var reallyClose = (buttonPressed == 0);

          // don't set the pref unless they press OK and it's false
          if (aCloseTabs == this.closingTabsEnum.ALL && reallyClose && !warnOnClose.value)
            Services.prefs.setBoolPref(pref, false);

          return reallyClose;
        
      
}
console.log: disabletabs: [object XULElement].getTabsToTheEndFrom = function getTabsToTheEndFrom(aTab) {

          
            var tabsToEnd = [];
            let tabs = this.visibleTabs;
            for (let i = tabs.length - 1; tabs[i] != aTab && i >= 0; --i) {
              tabsToEnd.push(tabs[i]);
            }
            return tabsToEnd.reverse();
          
        
}
console.log: disabletabs: [object XULElement].removeTabsToTheEndFrom = function removeTabsToTheEndFrom(aTab) {

          
            if (this.warnAboutClosingTabs(this.closingTabsEnum.TO_END, aTab)) {
              let tabs = this.getTabsToTheEndFrom(aTab);
              for (let i = tabs.length - 1; i >= 0; --i) {
                this.removeTab(tabs[i], {animate: true});
              }
            }
          
        
}
console.log: disabletabs: [object XULElement].removeAllTabsBut = function removeAllTabsBut(aTab) {

          
            if (aTab.pinned)
              return;

            if (this.warnAboutClosingTabs(this.closingTabsEnum.OTHER)) {
              let tabs = this.visibleTabs;
              this.selectedTab = aTab;

              for (let i = tabs.length - 1; i >= 0; --i) {
                if (tabs[i] != aTab && !tabs[i].pinned)
                  this.removeTab(tabs[i], {animate: true});
              }
            }
          
        
}
console.log: disabletabs: [object XULElement].removeCurrentTab = function removeCurrentTab(aParams) {

          
            this.removeTab(this.mCurrentTab, aParams);
          
        
}
console.log: disabletabs: [object XULElement].removeTab = function removeTab(aTab, aParams) {

          
            if (aParams) {
              var animate = aParams.animate;
              var byMouse = aParams.byMouse;
            }

            // Handle requests for synchronously removing an already
            // asynchronously closing tab.
            if (!animate &&
                aTab.closing) {
              this._endRemoveTab(aTab);
              return;
            }

            var isLastTab = (this.tabs.length - this._removingTabs.length == 1);

            if (!this._beginRemoveTab(aTab, false, null, true))
              return;

            if (!aTab.pinned && !aTab.hidden && aTab._fullyOpen && byMouse)
              this.tabContainer._lockTabSizing(aTab);
            else
              this.tabContainer._unlockTabSizing();

            if (!animate /* the caller didn't opt in */ ||
                isLastTab ||
                aTab.pinned ||
                aTab.hidden ||
                this._removingTabs.length > 3 /* don't want lots of concurrent animations */ ||
                aTab.getAttribute("fadein") != "true" /* fade-in transition hasn't been triggered yet */ ||
                window.getComputedStyle(aTab).maxWidth == "0.1px" /* fade-in transition hasn't moved yet */ ||
                !Services.prefs.getBoolPref("browser.tabs.animate")) {
              this._endRemoveTab(aTab);
              return;
            }

            this.tabContainer._handleTabTelemetryStart(aTab);

            this._blurTab(aTab);
            aTab.style.maxWidth = ""; // ensure that fade-out transition happens
            aTab.removeAttribute("fadein");

            setTimeout(function (tab, tabbrowser) {
              if (tab.parentNode &&
                  window.getComputedStyle(tab).maxWidth == "0.1px") {
                NS_ASSERT(false, "Giving up waiting for the tab closing animation to finish (bug 608589)");
                tabbrowser._endRemoveTab(tab);
              }
            }, 3000, aTab, this);
          
        
}
console.log: disabletabs: [object XULElement]._beginRemoveTab = function _beginRemoveTab(aTab, aTabWillBeMoved, aCloseWindowWithLastTab, aCloseWindowFastpath) {

          
            if (aTab.closing ||
                this._windowIsClosing)
              return false;

            var browser = this.getBrowserForTab(aTab);

            var closeWindow = false;
            var newTab = false;
            if (this.tabs.length - this._removingTabs.length == 1) {
              closeWindow = aCloseWindowWithLastTab != null ? aCloseWindowWithLastTab :
                            !window.toolbar.visible ||
                              Services.prefs.getBoolPref("browser.tabs.closeWindowWithLastTab");

              // Closing the tab and replacing it with a blank one is notably slower
              // than closing the window right away. If the caller opts in, take
              // the fast path.
              if (closeWindow &&
                  aCloseWindowFastpath &&
                  this._removingTabs.length == 0) {
                // This call actually closes the window, unless the user
                // cancels the operation.  We are finished here in both cases.
                this._windowIsClosing = window.closeWindow(true, window.warnAboutClosingWindow);
                return null;
              }

              newTab = true;
            }

            if (!aTab._pendingPermitUnload && !aTabWillBeMoved) {
              let ds = browser.docShell;
              if (ds && ds.contentViewer) {
                // We need to block while calling permitUnload() because it
                // processes the event queue and may lead to another removeTab()
                // call before permitUnload() returns.
                aTab._pendingPermitUnload = true;
                let permitUnload = ds.contentViewer.permitUnload();
                delete aTab._pendingPermitUnload;
                // If we were closed during onbeforeunload, we return false now
                // so we don't (try to) close the same tab again. Of course, we
                // also stop if the unload was cancelled by the user:
                if (aTab.closing || !permitUnload) {
                  // NB: deliberately keep the _closedDuringPermitUnload set to
                  // true so we keep exiting early in case of multiple calls.
                  return false;
                }
              }
            }

            aTab.closing = true;
            this._removingTabs.push(aTab);
            this._visibleTabs = null; // invalidate cache

            // Invalidate hovered tab state tracking for this closing tab.
            if (this.tabContainer._hoveredTab == aTab)
              aTab._mouseleave();

            if (newTab)
              this.addTab(BROWSER_NEW_TAB_URL, {skipAnimation: true});
            else
              this.tabContainer.updateVisibility();

            // We're committed to closing the tab now.
            // Dispatch a notification.
            // We dispatch it before any teardown so that event listeners can
            // inspect the tab that's about to close.
            var evt = document.createEvent("UIEvent");
            evt.initUIEvent("TabClose", true, false, window, aTabWillBeMoved ? 1 : 0);
            aTab.dispatchEvent(evt);

            if (!aTabWillBeMoved && !gMultiProcessBrowser) {
              // Prevent this tab from showing further dialogs, since we're closing it
              var windowUtils = browser.contentWindow.QueryInterface(Ci.nsIInterfaceRequestor).
                                getInterface(Ci.nsIDOMWindowUtils);
              windowUtils.disableDialogs();
            }

            // Remove the tab's filter and progress listener.
            const filter = this.mTabFilters[aTab._tPos];

            browser.webProgress.removeProgressListener(filter);

            filter.removeProgressListener(this.mTabListeners[aTab._tPos]);
            this.mTabListeners[aTab._tPos].destroy();

            if (browser.registeredOpenURI && !aTabWillBeMoved) {
              this._placesAutocomplete.unregisterOpenPage(browser.registeredOpenURI);
              this._unifiedComplete.unregisterOpenPage(browser.registeredOpenURI);
              delete browser.registeredOpenURI;
            }

            // We are no longer the primary content area.
            browser.setAttribute("type", "content-targetable");

            // Remove this tab as the owner of any other tabs, since it's going away.
            for (let tab of this.tabs) {
              if ("owner" in tab && tab.owner == aTab)
                // |tab| is a child of the tab we're removing, make it an orphan
                tab.owner = null;
            }

            aTab._endRemoveArgs = [closeWindow, newTab];
            return true;
          
        
}
console.log: disabletabs: [object XULElement]._endRemoveTab = function _endRemoveTab(aTab) {

          
            if (!aTab || !aTab._endRemoveArgs)
              return;

            var [aCloseWindow, aNewTab] = aTab._endRemoveArgs;
            aTab._endRemoveArgs = null;

            if (this._windowIsClosing) {
              aCloseWindow = false;
              aNewTab = false;
            }

            this._lastRelatedTab = null;

            // update the UI early for responsiveness
            aTab.collapsed = true;
            this.tabContainer._fillTrailingGap();
            this._blurTab(aTab);

            this._removingTabs.splice(this._removingTabs.indexOf(aTab), 1);

            if (aCloseWindow) {
              this._windowIsClosing = true;
              while (this._removingTabs.length)
                this._endRemoveTab(this._removingTabs[0]);
            } else if (!this._windowIsClosing) {
              if (aNewTab)
                focusAndSelectUrlBar();

              // workaround for bug 345399
              this.tabContainer.mTabstrip._updateScrollButtonsDisabledState();
            }

            // We're going to remove the tab and the browser now.
            // Clean up mTabFilters and mTabListeners now rather than in
            // _beginRemoveTab, so that their size is always in sync with the
            // number of tabs and browsers (the xbl destructor depends on this).
            this.mTabFilters.splice(aTab._tPos, 1);
            this.mTabListeners.splice(aTab._tPos, 1);

            var browser = this.getBrowserForTab(aTab);
            this._outerWindowIDBrowserMap.delete(browser.outerWindowID);

            // Because of the way XBL works (fields just set JS
            // properties on the element) and the code we have in place
            // to preserve the JS objects for any elements that have
            // JS properties set on them, the browser element won't be
            // destroyed until the document goes away.  So we force a
            // cleanup ourselves.
            // This has to happen before we remove the child so that the
            // XBL implementation of nsIObserver still works.
            browser.destroy();

            var wasPinned = aTab.pinned;

            // Invalidate browsers cache, as the tab is removed from the
            // tab container.
            this._browsers = null;

            // Remove the tab ...
            this.tabContainer.removeChild(aTab);

            // ... and fix up the _tPos properties immediately.
            for (let i = aTab._tPos; i < this.tabs.length; i++)
              this.tabs[i]._tPos = i;

            if (!this._windowIsClosing) {
              if (wasPinned)
                this.tabContainer._positionPinnedTabs();

              // update tab close buttons state
              this.tabContainer.adjustTabstrip();

              setTimeout(function(tabs) {
                tabs._lastTabClosedByMouse = false;
              }, 0, this.tabContainer);
            }

            // update tab positional properties and attributes
            this.selectedTab._selected = true;
            this.tabContainer._setPositionalAttributes();

            // Removing the panel requires fixing up selectedPanel immediately
            // (see below), which would be hindered by the potentially expensive
            // browser removal. So we remove the browser and the panel in two
            // steps.

            var panel = this.getNotificationBox(browser);

            // This will unload the document. An unload handler could remove
            // dependant tabs, so it's important that the tabbrowser is now in
            // a consistent state (tab removed, tab positions updated, etc.).
            browser.parentNode.removeChild(browser);

            // Release the browser in case something is erroneously holding a
            // reference to the tab after its removal.
            this._tabForBrowser.delete(aTab.linkedBrowser);
            aTab.linkedBrowser = null;

            // As the browser is removed, the removal of a dependent document can
            // cause the whole window to close. So at this point, it's possible
            // that the binding is destructed.
            if (this.mTabBox) {
              this.mPanelContainer.removeChild(panel);
            }

            if (aCloseWindow)
              this._windowIsClosing = closeWindow(true, window.warnAboutClosingWindow);
          
        
}
console.log: disabletabs: [object XULElement]._blurTab = function _blurTab(aTab) {

          
            if (!aTab.selected)
              return;

            if (aTab.owner &&
                !aTab.owner.hidden &&
                !aTab.owner.closing &&
                Services.prefs.getBoolPref("browser.tabs.selectOwnerOnClose")) {
              this.selectedTab = aTab.owner;
              return;
            }

            // Switch to a visible tab unless there aren't any others remaining
            let remainingTabs = this.visibleTabs;
            let numTabs = remainingTabs.length;
            if (numTabs == 0 || numTabs == 1 && remainingTabs[0] == aTab) {
              remainingTabs = Array.filter(this.tabs, function(tab) {
                return !tab.closing;
              }, this);
            }

            // Try to find a remaining tab that comes after the given tab
            var tab = aTab;
            do {
              tab = tab.nextSibling;
            } while (tab && remainingTabs.indexOf(tab) == -1);

            if (!tab) {
              tab = aTab;

              do {
                tab = tab.previousSibling;
              } while (tab && remainingTabs.indexOf(tab) == -1);
            }

            this.selectedTab = tab;
          
        
}
console.log: disabletabs: [object XULElement].swapNewTabWithBrowser = function swapNewTabWithBrowser(aNewTab, aBrowser) {

          
            // The browser must be standalone.
            if (aBrowser.getTabBrowser())
              throw Cr.NS_ERROR_INVALID_ARG;

            // The tab is definitely not loading.
            aNewTab.removeAttribute("busy");
            if (aNewTab.selected) {
              this.mIsBusy = false;
            }

            this._swapBrowserDocShells(aNewTab, aBrowser);

            // Update the new tab's title.
            this.setTabTitle(aNewTab);

            if (aNewTab.selected) {
              this.updateCurrentBrowser(true);
            }
          
        
}
console.log: disabletabs: [object XULElement].swapBrowsersAndCloseOther = function swapBrowsersAndCloseOther(aOurTab, aOtherTab) {

          
            // Do not allow transfering a private tab to a non-private window
            // and vice versa.
            if (PrivateBrowsingUtils.isWindowPrivate(window) !=
                PrivateBrowsingUtils.isWindowPrivate(aOtherTab.ownerDocument.defaultView))
              return;

            let ourBrowser = this.getBrowserForTab(aOurTab);
            let otherBrowser = aOtherTab.linkedBrowser;

            // Can't swap between chrome and content processes.
            if (ourBrowser.isRemoteBrowser != otherBrowser.isRemoteBrowser)
              return;

            // Keep the userContextId if set on other browser
            if (otherBrowser.hasAttribute("usercontextid")) {
              ourBrowser.setAttribute("usercontextid", otherBrowser.getAttribute("usercontextid"));
            }

            // That's gBrowser for the other window, not the tab's browser!
            var remoteBrowser = aOtherTab.ownerDocument.defaultView.gBrowser;
            var isPending = aOtherTab.hasAttribute("pending");

            // First, start teardown of the other browser.  Make sure to not
            // fire the beforeunload event in the process.  Close the other
            // window if this was its last tab.
            if (!remoteBrowser._beginRemoveTab(aOtherTab, true, true))
              return;

            let modifiedAttrs = [];
            if (aOtherTab.hasAttribute("muted")) {
              aOurTab.setAttribute("muted", "true");
              ourBrowser.mute();
              modifiedAttrs.push("muted");
            }
            if (aOtherTab.hasAttribute("soundplaying")) {
              aOurTab.setAttribute("soundplaying", "true");
              modifiedAttrs.push("soundplaying");
            }
            if (aOtherTab.hasAttribute("usercontextid")) {
              aOurTab.setAttribute("usercontextid", aOtherTab.getAttribute("usercontextid"));
              modifiedAttrs.push("usercontextid");
            }

            // If the other tab is pending (i.e. has not been restored, yet)
            // then do not switch docShells but retrieve the other tab's state
            // and apply it to our tab.
            if (isPending) {
              SessionStore.setTabState(aOurTab, SessionStore.getTabState(aOtherTab));

              // Make sure to unregister any open URIs.
              this._swapRegisteredOpenURIs(ourBrowser, otherBrowser);
            } else {
              // Workarounds for bug 458697
              // Icon might have been set on DOMLinkAdded, don't override that.
              if (!ourBrowser.mIconURL && otherBrowser.mIconURL)
                this.setIcon(aOurTab, otherBrowser.mIconURL);
              var isBusy = aOtherTab.hasAttribute("busy");
              if (isBusy) {
                aOurTab.setAttribute("busy", "true");
                modifiedAttrs.push("busy");
                if (aOurTab.selected)
                  this.mIsBusy = true;
              }

              this._swapBrowserDocShells(aOurTab, otherBrowser);
            }

            // Handle findbar data (if any)
            let otherFindBar = aOtherTab._findBar;
            if (otherFindBar &&
                otherFindBar.findMode == otherFindBar.FIND_NORMAL) {
              let ourFindBar = this.getFindBar(aOurTab);
              ourFindBar._findField.value = otherFindBar._findField.value;
              if (!otherFindBar.hidden)
                ourFindBar.onFindCommand();
            }

            // Finish tearing down the tab that's going away.
            remoteBrowser._endRemoveTab(aOtherTab);

            if (isBusy)
              this.setTabTitleLoading(aOurTab);
            else
              this.setTabTitle(aOurTab);

            // If the tab was already selected (this happpens in the scenario
            // of replaceTabWithWindow), notify onLocationChange, etc.
            if (aOurTab.selected)
              this.updateCurrentBrowser(true);

            if (modifiedAttrs.length) {
              this._tabAttrModified(aOurTab, modifiedAttrs);
            }
          
        
}
console.log: disabletabs: [object XULElement]._swapBrowserDocShells = function _swapBrowserDocShells(aOurTab, aOtherBrowser) {

          
            // Unhook our progress listener
            let index = aOurTab._tPos;
            const filter = this.mTabFilters[index];
            let tabListener = this.mTabListeners[index];
            let ourBrowser = this.getBrowserForTab(aOurTab);
            ourBrowser.webProgress.removeProgressListener(filter);
            filter.removeProgressListener(tabListener);

            // Make sure to unregister any open URIs.
            this._swapRegisteredOpenURIs(ourBrowser, aOtherBrowser);

            // Unmap old outerWindowIDs.
            this._outerWindowIDBrowserMap.delete(ourBrowser.outerWindowID);
            let remoteBrowser = aOtherBrowser.ownerDocument.defaultView.gBrowser;
            if (remoteBrowser) {
              remoteBrowser._outerWindowIDBrowserMap.delete(aOtherBrowser.outerWindowID);
            }

            aOtherBrowser.docShellIsActive = (ourBrowser == this.selectedBrowser &&
                                              window.windowState != window.STATE_MINIMIZED);

            // Swap the docshells
            ourBrowser.swapDocShells(aOtherBrowser);

            if (ourBrowser.isRemoteBrowser) {
              // Switch outerWindowIDs for remote browsers.
              let ourOuterWindowID = ourBrowser._outerWindowID;
              ourBrowser._outerWindowID = aOtherBrowser._outerWindowID;
              aOtherBrowser._outerWindowID = ourOuterWindowID;
            }

            // Register new outerWindowIDs.
            this._outerWindowIDBrowserMap.set(ourBrowser.outerWindowID, ourBrowser);
            if (remoteBrowser) {
              remoteBrowser._outerWindowIDBrowserMap.set(aOtherBrowser.outerWindowID, aOtherBrowser);
            }

            // Swap permanentKey properties.
            let ourPermanentKey = ourBrowser.permanentKey;
            ourBrowser.permanentKey = aOtherBrowser.permanentKey;
            aOtherBrowser.permanentKey = ourPermanentKey;

            // Restore the progress listener
            this.mTabListeners[index] = tabListener =
              this.mTabProgressListener(aOurTab, ourBrowser, false, false);

            const notifyAll = Ci.nsIWebProgress.NOTIFY_ALL;
            filter.addProgressListener(tabListener, notifyAll);
            ourBrowser.webProgress.addProgressListener(filter, notifyAll);
          
        
}
console.log: disabletabs: [object XULElement]._swapRegisteredOpenURIs = function _swapRegisteredOpenURIs(aOurBrowser, aOtherBrowser) {

          
            // If the current URI is registered as open remove it from the list.
            if (aOurBrowser.registeredOpenURI) {
              this._placesAutocomplete.unregisterOpenPage(aOurBrowser.registeredOpenURI);
              this._unifiedComplete.unregisterOpenPage(aOurBrowser.registeredOpenURI);
              delete aOurBrowser.registeredOpenURI;
            }

            // If the other/new URI is registered as open then copy it over.
            if (aOtherBrowser.registeredOpenURI) {
              aOurBrowser.registeredOpenURI = aOtherBrowser.registeredOpenURI;
              delete aOtherBrowser.registeredOpenURI;
            }
          
        
}
console.log: disabletabs: [object XULElement].reloadAllTabs = function reloadAllTabs() {

          
            let tabs = this.visibleTabs;
            let l = tabs.length;
            for (var i = 0; i < l; i++) {
              try {
                this.getBrowserForTab(tabs[i]).reload();
              } catch (e) {
                // ignore failure to reload so others will be reloaded
              }
            }
          
        
}
console.log: disabletabs: [object XULElement].reloadTab = function reloadTab(aTab) {

          
            this.getBrowserForTab(aTab).reload();
          
        
}
console.log: disabletabs: [object XULElement].addProgressListener = function addProgressListener(aListener) {

          
            if (arguments.length != 1) {
              Components.utils.reportError("gBrowser.addProgressListener was " +
                                           "called with a second argument, " +
                                           "which is not supported. See bug " +
                                           "608628. Call stack: " + new Error().stack);
            }

            this.mProgressListeners.push(aListener);
          
        
}
console.log: disabletabs: [object XULElement].removeProgressListener = function removeProgressListener(aListener) {

          
            this.mProgressListeners =
              this.mProgressListeners.filter(l => l != aListener);
         
        
}
console.log: disabletabs: [object XULElement].addTabsProgressListener = function addTabsProgressListener(aListener) {

          this.mTabsProgressListeners.push(aListener);
        
}
console.log: disabletabs: [object XULElement].removeTabsProgressListener = function removeTabsProgressListener(aListener) {

        
          this.mTabsProgressListeners =
            this.mTabsProgressListeners.filter(l => l != aListener);
        
        
}
console.log: disabletabs: [object XULElement].getBrowserForTab = function getBrowserForTab(aTab) {

        
          return aTab.linkedBrowser;
        
        
}
console.log: disabletabs: [object XULElement].showOnlyTheseTabs = function showOnlyTheseTabs(aTabs) {

        
          for (let tab of this.tabs) {
            if (aTabs.indexOf(tab) == -1)
              this.hideTab(tab);
            else
              this.showTab(tab);
          }

          this.tabContainer._handleTabSelect(false);
        
        
}
console.log: disabletabs: [object XULElement].showTab = function showTab(aTab) {

        
          if (aTab.hidden) {
            aTab.removeAttribute("hidden");
            this._visibleTabs = null; // invalidate cache

            this.tabContainer.adjustTabstrip();

            this.tabContainer._setPositionalAttributes();

            let event = document.createEvent("Events");
            event.initEvent("TabShow", true, false);
            aTab.dispatchEvent(event);
          }
        
        
}
console.log: disabletabs: [object XULElement].hideTab = function hideTab(aTab) {

        
          if (!aTab.hidden && !aTab.pinned && !aTab.selected &&
              !aTab.closing) {
            aTab.setAttribute("hidden", "true");
            this._visibleTabs = null; // invalidate cache

            this.tabContainer.adjustTabstrip();

            this.tabContainer._setPositionalAttributes();

            let event = document.createEvent("Events");
            event.initEvent("TabHide", true, false);
            aTab.dispatchEvent(event);
          }
        
        
}
console.log: disabletabs: [object XULElement].selectTabAtIndex = function selectTabAtIndex(aIndex, aEvent) {

        
          let tabs = this.visibleTabs;

          // count backwards for aIndex < 0
          if (aIndex < 0)
            aIndex += tabs.length;

          if (aIndex >= 0 && aIndex < tabs.length)
            this.selectedTab = tabs[aIndex];

          if (aEvent) {
            aEvent.preventDefault();
            aEvent.stopPropagation();
          }
        
        
}
console.log: disabletabs: [object XULElement].selectedTab = [object XULElement]
console.log: disabletabs: [object XULElement].selectedBrowser = [object XULElement]
console.log: disabletabs: [object XULElement].browsers = [object XULElement]
console.log: disabletabs: [object XULElement].replaceTabWithWindow = function replaceTabWithWindow(aTab, aOptions) {

          
            if (this.tabs.length == 1)
              return null;

            var options = "chrome,dialog=no,all";
            for (var name in aOptions)
              options += "," + name + "=" + aOptions[name];

            // tell a new window to take the "dropped" tab
            return window.openDialog(getBrowserURL(), "_blank", options, aTab);
          
        
}
console.log: disabletabs: [object XULElement].openNonRemoteWindow = function openNonRemoteWindow(aTab) {

          
            if (!this.AppConstants.E10S_TESTING_ONLY) {
              throw "This method is intended only for e10s testing!";
            }
            let url = aTab.linkedBrowser.currentURI.spec;
            return window.openDialog("chrome://browser/content/", "_blank", "chrome,all,dialog=no,non-remote", url);
          
        
}
console.log: disabletabs: [object XULElement].moveTabTo = function moveTabTo(aTab, aIndex) {

        
          var oldPosition = aTab._tPos;
          if (oldPosition == aIndex)
            return;

          // Don't allow mixing pinned and unpinned tabs.
          if (aTab.pinned)
            aIndex = Math.min(aIndex, this._numPinnedTabs - 1);
          else
            aIndex = Math.max(aIndex, this._numPinnedTabs);
          if (oldPosition == aIndex)
            return;

          this._lastRelatedTab = null;

          this.mTabFilters.splice(aIndex, 0, this.mTabFilters.splice(aTab._tPos, 1)[0]);
          this.mTabListeners.splice(aIndex, 0, this.mTabListeners.splice(aTab._tPos, 1)[0]);

          let wasFocused = (document.activeElement == this.mCurrentTab);

          aIndex = aIndex < aTab._tPos ? aIndex: aIndex+1;
          this.mCurrentTab._logicallySelected = false;
          this.mCurrentTab._visuallySelected = false;

          // invalidate caches
          this._browsers = null;
          this._visibleTabs = null;

          // use .item() instead of [] because dragging to the end of the strip goes out of
          // bounds: .item() returns null (so it acts like appendChild), but [] throws
          this.tabContainer.insertBefore(aTab, this.tabs.item(aIndex));

          for (let i = 0; i < this.tabs.length; i++) {
            this.tabs[i]._tPos = i;
            this.tabs[i]._logicallySelected = false;
            this.tabs[i]._visuallySelected = false;
          }
          this.mCurrentTab._logicallySelected = true;
          this.mCurrentTab._visuallySelected = true;

          if (wasFocused)
            this.mCurrentTab.focus();

          this.tabContainer._handleTabSelect(false);

          if (aTab.pinned)
            this.tabContainer._positionPinnedTabs();

          this.tabContainer._setPositionalAttributes();

          var evt = document.createEvent("UIEvents");
          evt.initUIEvent("TabMove", true, false, window, oldPosition);
          aTab.dispatchEvent(evt);
        
        
}
console.log: disabletabs: [object XULElement].moveTabForward = function moveTabForward() {

          
            let nextTab = this.mCurrentTab.nextSibling;
            while (nextTab && nextTab.hidden)
              nextTab = nextTab.nextSibling;

            if (nextTab)
              this.moveTabTo(this.mCurrentTab, nextTab._tPos);
            else if (this.arrowKeysShouldWrap)
              this.moveTabToStart();
          
        
}
console.log: disabletabs: [object XULElement].moveTabBackward = function moveTabBackward() {

          
            let previousTab = this.mCurrentTab.previousSibling;
            while (previousTab && previousTab.hidden)
              previousTab = previousTab.previousSibling;

            if (previousTab)
              this.moveTabTo(this.mCurrentTab, previousTab._tPos);
            else if (this.arrowKeysShouldWrap)
              this.moveTabToEnd();
          
        
}
console.log: disabletabs: [object XULElement].moveTabToStart = function moveTabToStart() {

          
            var tabPos = this.mCurrentTab._tPos;
            if (tabPos > 0)
              this.moveTabTo(this.mCurrentTab, 0);
          
        
}
console.log: disabletabs: [object XULElement].moveTabToEnd = function moveTabToEnd() {

          
            var tabPos = this.mCurrentTab._tPos;
            if (tabPos < this.browsers.length - 1)
              this.moveTabTo(this.mCurrentTab, this.browsers.length - 1);
          
        
}
console.log: disabletabs: [object XULElement].moveTabOver = function moveTabOver(aEvent) {

          
            var direction = window.getComputedStyle(this.parentNode, null).direction;
            if ((direction == "ltr" && aEvent.keyCode == KeyEvent.DOM_VK_RIGHT) ||
                (direction == "rtl" && aEvent.keyCode == KeyEvent.DOM_VK_LEFT))
              this.moveTabForward();
            else
              this.moveTabBackward();
          
        
}
console.log: disabletabs: [object XULElement].duplicateTab = function duplicateTab(aTab) {

          
            return SessionStore.duplicateTab(window, aTab);
          
        
}
console.log: disabletabs: [object XULElement]._getSwitcher = function _getSwitcher() {

          if (this._switcher) {
            return this._switcher;
          }

          let switcher = {
            // How long to wait for a tab's layers to load. After this
            // time elapses, we're free to put up the spinner and start
            // trying to load a different tab.
            TAB_SWITCH_TIMEOUT: 400 /* ms */,

            // When the user hasn't switched tabs for this long, we unload
            // layers for all tabs that aren't in use.
            UNLOAD_DELAY: 300 /* ms */,

            // The next three tabs form the principal state variables.
            // See the assertions in postActions for their invariants.

            // Tab the user requested most recently.
            requestedTab: this.selectedTab,

            // Tab we're currently trying to load.
            loadingTab: null,

            // We show this tab in case the requestedTab hasn't loaded yet.
            lastVisibleTab: this.selectedTab,

            // Auxilliary state variables:

            visibleTab: this.selectedTab,   // Tab that's on screen.
            spinnerTab: null,               // Tab showing a spinner.
            originalTab: this.selectedTab,  // Tab that we started on.

            tabbrowser: this,  // Reference to gBrowser.
            loadTimer: null,   // TAB_SWITCH_TIMEOUT timer.
            unloadTimer: null, // UNLOAD_DELAY timer.

            // Map from tabs to STATE_* (below).
            tabState: new Map(),

            // Keep an exact list of content processes (tabParent) in which
            // we're actively suppressing the display port. This gives a robust
            // way to make sure we don't forget to un-suppress.
            activeSuppressDisplayport: new Set(),

            // Set of tabs that might be visible right now. We maintain
            // this set because we can't be sure when a tab is actually
            // drawn. A tab is added to this set when we ask to make it
            // visible. All tabs but the most recently shown tab are
            // removed from the set upon MozAfterPaint.
            maybeVisibleTabs: new Set([this.selectedTab]),

            STATE_UNLOADED: 0,
            STATE_LOADING: 1,
            STATE_LOADED: 2,
            STATE_UNLOADING: 3,

            // re-entrancy guard:
            _processing: false,

            getTabState: function(tab) {
              let state = this.tabState.get(tab);
              if (state === undefined) {
                return this.STATE_UNLOADED;
              }
              return state;
            },

            setTabState: function(tab, state) {
              if (state == this.STATE_UNLOADED) {
                this.tabState.delete(tab);
              } else {
                this.tabState.set(tab, state);
              }

              let browser = tab.linkedBrowser;
              let fl = browser.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader;
              if (state == this.STATE_LOADING) {
                // Ask for a MozLayerTreeReady event.
                fl.requestNotifyLayerTreeReady();
                browser.docShellIsActive = true;
              } else if (state == this.STATE_UNLOADING) {
                // Ask for MozLayerTreeCleared event.
                fl.requestNotifyLayerTreeCleared();
                browser.docShellIsActive = false;
              }
            },

            init: function() {
              this.log("START");

              window.addEventListener("MozAfterPaint", this);
              window.addEventListener("MozLayerTreeReady", this);
              window.addEventListener("MozLayerTreeCleared", this);
              window.addEventListener("TabRemotenessChange", this);
              this.setTabState(this.requestedTab, this.STATE_LOADED);
            },

            destroy: function() {
              clearTimeout(this.unloadTimer);
              clearTimeout(this.loadTimer);

              window.removeEventListener("MozAfterPaint", this);
              window.removeEventListener("MozLayerTreeReady", this);
              window.removeEventListener("MozLayerTreeCleared", this);
              window.removeEventListener("TabRemotenessChange", this);

              this.tabbrowser._switcher = null;

              this.activeSuppressDisplayport.forEach(function(tabParent) {
                tabParent.suppressDisplayport(false);
              });
              this.activeSuppressDisplayport.clear();
            },

            finish: function() {
              this.log("FINISH");

              this.assert(this.tabbrowser._switcher);
              this.assert(this.tabbrowser._switcher === this);
              this.assert(!this.spinnerTab);
              this.assert(!this.loadTimer);
              this.assert(!this.loadingTab);
              this.assert(this.lastVisibleTab === this.requestedTab);
              this.assert(this.getTabState(this.requestedTab) == this.STATE_LOADED);

              this.destroy();

              let toBrowser = this.requestedTab.linkedBrowser;
              toBrowser.setAttribute("type", "content-primary");

              this.tabbrowser._adjustFocusAfterTabSwitch(this.requestedTab);

              let fromBrowser = this.originalTab.linkedBrowser;
              // It's possible that the tab we're switching from closed
              // before we were able to finalize, in which case, fromBrowser
              // doesn't exist.
              if (fromBrowser) {
                fromBrowser.setAttribute("type", "content-targetable");
              }

              let event = new CustomEvent("TabSwitchDone", {
                bubbles: true,
                cancelable: true
              });
              this.tabbrowser.dispatchEvent(event);
            },

            // This function is called after all the main state changes to
            // make sure we display the right tab.
            updateDisplay: function() {
              // Figure out which tab we actually want visible right now.
              let showTab = null;
              if (this.getTabState(this.requestedTab) != this.STATE_LOADED &&
                  this.lastVisibleTab && this.loadTimer) {
                // If we can't show the requestedTab, and lastVisibleTab is
                // available, show it.
                showTab = this.lastVisibleTab;
              } else {
                // Show the requested tab. If it's not available, we'll show the spinner.
                showTab = this.requestedTab;
              }

              // Show or hide the spinner as needed.
              let needSpinner = this.getTabState(showTab) != this.STATE_LOADED;
              if (!needSpinner && this.spinnerTab) {
                this.spinnerHidden();
                this.tabbrowser.removeAttribute("pendingpaint");
                this.spinnerTab.linkedBrowser.removeAttribute("pendingpaint");
                this.spinnerTab = null;
              } else if (needSpinner && this.spinnerTab !== showTab) {
                if (this.spinnerTab) {
                  this.spinnerTab.linkedBrowser.removeAttribute("pendingpaint");
                } else {
                  this.spinnerDisplayed();
                }
                this.spinnerTab = showTab;
                this.tabbrowser.setAttribute("pendingpaint", "true");
                this.spinnerTab.linkedBrowser.setAttribute("pendingpaint", "true");
              }

              // Switch to the tab we've decided to make visible.
              if (this.visibleTab !== showTab) {
                this.visibleTab = showTab;

                this.maybeVisibleTabs.add(showTab);

                let tabs = this.tabbrowser.mTabBox.tabs;
                let tabPanel = this.tabbrowser.mPanelContainer;
                let showPanel = tabs.getRelatedElement(showTab);
                let index = Array.indexOf(tabPanel.childNodes, showPanel);
                if (index != -1) {
                  this.log(`Switch to tab ${index} - ${this.tinfo(showTab)}`);
                  tabPanel.setAttribute("selectedIndex", index);
                  if (showTab === this.requestedTab) {
                    this.tabbrowser._adjustFocusAfterTabSwitch(showTab);
                  }
                }

                // This doesn't necessarily exist if we're a new window and haven't switched tabs yet
                if (this.lastVisibleTab)
                  this.lastVisibleTab._visuallySelected = false;

                this.visibleTab._visuallySelected = true;
              }

              this.lastVisibleTab = this.visibleTab;
            },

            assert: function(cond) {
              if (!cond) {
                dump("Assertion failure\n" + Error().stack);
                throw new Error("Assertion failure");
              }
            },

            // We've decided to try to load requestedTab.
            loadRequestedTab: function() {
              this.assert(!this.loadTimer);

              // loadingTab can be non-null here if we timed out loading the current tab.
              // In that case we just overwrite it with a different tab; it's had its chance.
              this.loadingTab = this.requestedTab;
              this.log("Loading tab " + this.tinfo(this.loadingTab));

              this.setTabState(this.requestedTab, this.STATE_LOADING);
              this.loadTimer = setTimeout(() => this.onLoadTimeout(), this.TAB_SWITCH_TIMEOUT);
            },

            // This function runs before every event. It fixes up the state
            // to account for closed tabs.
            preActions: function() {
              this.assert(this.tabbrowser._switcher);
              this.assert(this.tabbrowser._switcher === this);

              for (let [tab, state] of this.tabState) {
                if (!tab.linkedBrowser) {
                  this.tabState.delete(tab);
                }
              }

              if (this.lastVisibleTab && !this.lastVisibleTab.linkedBrowser) {
                this.lastVisibleTab = null;
              }
              if (this.spinnerTab && !this.spinnerTab.linkedBrowser) {
                this.spinnerHidden();
                this.spinnerTab = null;
              }
              if (this.loadingTab && !this.loadingTab.linkedBrowser) {
                this.loadingTab = null;
                clearTimeout(this.loadTimer);
                this.loadTimer = null;
              }
            },

            // This code runs after we've responded to an event or requested a new
            // tab. It's expected that we've already updated all the principal
            // state variables. This function takes care of updating any auxilliary
            // state.
            postActions: function() {
              // Once we finish loading loadingTab, we null it out. So the state should
              // always be LOADING.
              this.assert(!this.loadingTab ||
                          this.getTabState(this.loadingTab) == this.STATE_LOADING);

              // We guarantee that loadingTab is non-null iff loadTimer is non-null. So
              // the timer is set only when we're loading something.
              this.assert(!this.loadTimer || this.loadingTab);
              this.assert(!this.loadingTab || this.loadTimer);

              // If we're not loading anything, try loading the requested tab.
              if (!this.loadTimer && this.getTabState(this.requestedTab) == this.STATE_UNLOADED) {
                this.loadRequestedTab();
              }

              // See how many tabs still have work to do.
              let numPending = 0;
              for (let [tab, state] of this.tabState) {
                if (state == this.STATE_LOADED && tab !== this.requestedTab) {
                  numPending++;
                }
                if (state == this.STATE_LOADING || state == this.STATE_UNLOADING) {
                  numPending++;
                }
              }

              this.updateDisplay();

              // It's possible for updateDisplay to trigger one of our own event
              // handlers, which might cause finish() to already have been called.
              // Check for that before calling finish() again.
              if (!this.tabbrowser._switcher) {
                return;
              }

              if (numPending == 0) {
                this.finish();
              }

              this.logState("done");
            },

            // Fires when we're ready to unload unused tabs.
            onUnloadTimeout: function() {
              this.logState("onUnloadTimeout");
              this.preActions();

              let numPending = 0;

              // Unload any tabs that can be unloaded.
              for (let [tab, state] of this.tabState) {
                if (state == this.STATE_LOADED &&
                    !this.maybeVisibleTabs.has(tab) &&
                    tab !== this.lastVisibleTab &&
                    tab !== this.loadingTab &&
                    tab !== this.requestedTab)
                {
                  this.setTabState(tab, this.STATE_UNLOADING);
                }

                if (state != this.STATE_UNLOADED && tab !== this.requestedTab) {
                  numPending++;
                }
              }

              if (numPending) {
                // Keep the timer going since there may be more tabs to unload.
                this.unloadTimer = setTimeout(() => this.onUnloadTimeout(), this.UNLOAD_DELAY);
              }

              this.postActions();
            },

            // Fires when an ongoing load has taken too long.
            onLoadTimeout: function() {
              this.logState("onLoadTimeout");
              this.preActions();
              this.loadTimer = null;
              this.loadingTab = null;
              this.postActions();
            },

            // Fires when the layers become available for a tab.
            onLayersReady: function(browser) {
              this.logState("onLayersReady");

              let tab = this.tabbrowser.getTabForBrowser(browser);
              this.setTabState(tab, this.STATE_LOADED);

              this.finishTabSwitch();

              if (this.loadingTab === tab) {
                clearTimeout(this.loadTimer);
                this.loadTimer = null;
                this.loadingTab = null;
              }
            },

            // Fires when we paint the screen. Any tab switches we initiated
            // previously are done, so there's no need to keep the old layers
            // around.
            onPaint: function() {
              this.maybeVisibleTabs.clear();
              this.finishTabSwitch();
            },

            // Called when we're done clearing the layers for a tab.
            onLayersCleared: function(browser) {
              this.logState("onLayersCleared");

              let tab = this.tabbrowser.getTabForBrowser(browser);
              if (tab) {
                this.setTabState(tab, this.STATE_UNLOADED);
              }
            },

            // Called when a tab switches from remote to non-remote. In this case
            // a MozLayerTreeReady notification that we requested may never fire,
            // so we need to simulate it.
            onRemotenessChange: function(tab) {
              this.logState("onRemotenessChange");
              if (!tab.linkedBrowser.isRemoteBrowser) {
                if (this.getTabState(tab) == this.STATE_LOADING) {
                  this.onLayersReady(tab.linkedBrowser);
                } else if (this.getTabState(tab) == this.STATE_UNLOADING) {
                  this.onLayersCleared(tab.linkedBrowser);
                }
              }
            },

            // Called when the user asks to switch to a given tab.
            requestTab: function(tab) {
              if (tab === this.requestedTab) {
                return;
              }

              // Instrumentation to figure out bug 1166351 - if the binding
              // on the browser we're switching to has gone away, try to find out
              // why. We should remove this and the checkBrowserBindingAlive
              // method once bug 1166351 has been closed.
              if (this.tabbrowser.AppConstants.E10S_TESTING_ONLY &&
                  !this.checkBrowserBindingAlive(tab)) {
                Cu.reportError("Please report the above errors in bug 1166351.");
                return;
              }

              this.logState("requestTab " + this.tinfo(tab));
              this.startTabSwitch();

              this.requestedTab = tab;

              let browser = this.requestedTab.linkedBrowser;
              let fl = browser.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader;
              if (fl && fl.tabParent && !this.activeSuppressDisplayport.has(fl.tabParent)) {
                fl.tabParent.suppressDisplayport(true);
                this.activeSuppressDisplayport.add(fl.tabParent);
              }

              this.preActions();

              clearTimeout(this.unloadTimer);
              this.unloadTimer = setTimeout(() => this.onUnloadTimeout(), this.UNLOAD_DELAY);

              this.postActions();
            },

            handleEvent: function(event, delayed = false) {
              if (this._processing) {
                setTimeout(() => this.handleEvent(event, true), 0);
                return;
              }
              if (delayed && this.tabbrowser._switcher != this) {
                // if we delayed processing this event, we might be out of date, in which
                // case we drop the delayed events
                return;
              }
              this._processing = true;
              this.preActions();

              if (event.type == "MozLayerTreeReady") {
                this.onLayersReady(event.originalTarget);
              } if (event.type == "MozAfterPaint") {
                this.onPaint();
              } else if (event.type == "MozLayerTreeCleared") {
                this.onLayersCleared(event.originalTarget);
              } else if (event.type == "TabRemotenessChange") {
                this.onRemotenessChange(event.target);
              }

              this.postActions();
              this._processing = false;
            },

            /*
             * Telemetry and Profiler related helpers for recording tab switch
             * timing.
             */

            startTabSwitch: function () {
              TelemetryStopwatch.cancel("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
              TelemetryStopwatch.start("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
              this.addMarker("AsyncTabSwitch:Start");
            },

            finishTabSwitch: function () {
              if (this.requestedTab && this.getTabState(this.requestedTab) == this.STATE_LOADED) {
                // After this point the tab has switched from the content thread's point of view.
                // The changes will be visible after the next refresh driver tick + composite.
                let event = new CustomEvent("TabSwitched", {
                  bubbles: true,
                  cancelable: true
                });
                this.tabbrowser.dispatchEvent(event);
                let time = TelemetryStopwatch.timeElapsed("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
                if (time != -1) {
                  TelemetryStopwatch.finish("FX_TAB_SWITCH_TOTAL_E10S_MS", window);
                  this.log("DEBUG: tab switch time = " + time);
                  this.addMarker("AsyncTabSwitch:Finish");
                }
              }
            },

            spinnerDisplayed: function () {
              this.assert(!this.spinnerTab);
              TelemetryStopwatch.start("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window);
              this.addMarker("AsyncTabSwitch:SpinnerShown");
            },

            spinnerHidden: function () {
              this.assert(this.spinnerTab);
              this.log("DEBUG: spinner time = " +
                       TelemetryStopwatch.timeElapsed("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window));
              TelemetryStopwatch.finish("FX_TAB_SWITCH_SPINNER_VISIBLE_MS", window);
              this.addMarker("AsyncTabSwitch:SpinnerHidden");
              // we do not get a onPaint after displaying the spinner
              this.finishTabSwitch();
            },

            addMarker: function(marker) {
              if (Services.profiler) {
                Services.profiler.AddMarker(marker);
              }
            },

            /*
             * Debug related logging for switcher.
             */

            _useDumpForLogging: false,
            _logInit: false,

            logging: function () {
              if (this._useDumpForLogging)
                return true;
              if (this._logInit)
                return this._shouldLog;
              let result = false;
              try {
                result = Services.prefs.getBoolPref("browser.tabs.remote.logSwitchTiming");
              } catch (ex) {
              }
              this._shouldLog = result;
              this._logInit = true;
              return this._shouldLog;
            },

            // Instrumentation for bug 1166351
            checkBrowserBindingAlive: function(tab) {
              let err = Cu.reportError;

              if (!tab.linkedBrowser) {
                err("Attempting to switch to tab that has no linkedBrowser.");
                return false;
              }

              let b = tab.linkedBrowser;

              if (!b._alive) {
                // The browser binding has been removed. Dump a bunch of
                // diagnostic information to the browser console.
                let utils = Cc["@mozilla.org/inspector/dom-utils;1"].getService(Ci.inIDOMUtils);
                let results = utils.getBindingURLs(b);
                let urls = [];

                for (let i = 0; i < results.length; ++i) {
                  urls.push(results.queryElementAt(i, Ci.nsIURI).spec);
                }
                err("The browser has the following bindings:");
                err(urls);
                err("MozBinding is currently: " +
                    window.getComputedStyle(b).MozBinding);
                if (!b.parentNode) {
                  err("Browser was removed from the DOM.");
                } else {
                  err("Parent is: " + b.parentNode.outerHTML);
                }
                return false;
              }

              return true;
            },

            tinfo: function(tab) {
              if (tab) {
                return tab._tPos + "(" + tab.linkedBrowser.currentURI.spec + ")";
              } else {
                return "null";
              }
            },

            log: function(s) {
              if (!this.logging())
                return;
              if (this._useDumpForLogging) {
                dump(s + "\n");
              } else {
                Services.console.logStringMessage(s);
              }
            },

            logState: function(prefix) {
              if (!this.logging())
                return;

              let accum = prefix + " ";
              for (let i = 0; i < this.tabbrowser.tabs.length; i++) {
                let tab = this.tabbrowser.tabs[i];
                let state = this.getTabState(tab);

                accum += i + ":";
                if (tab === this.lastVisibleTab) dump("V");
                if (tab === this.loadingTab) dump("L");
                if (tab === this.requestedTab) dump("R");
                if (state == this.STATE_LOADED) dump("(+)");
                if (state == this.STATE_LOADING) dump("(+?)");
                if (state == this.STATE_UNLOADED) dump("(-)");
                if (state == this.STATE_UNLOADING) dump("(-?)");
                accum += " ";
              }
              if (this._useDumpForLogging) {
                dump(accum + "\n");
              } else {
                Services.console.logStringMessage(accum);
              }
            },
          };
          this._switcher = switcher;
          switcher.init();
          return switcher;
        
}
console.log: disabletabs: [object XULElement].canGoBack = false
console.log: disabletabs: [object XULElement].canGoForward = false
console.log: disabletabs: [object XULElement].goBack = function goBack() {

          
            return this.mCurrentBrowser.goBack();
          
        
}
console.log: disabletabs: [object XULElement].goForward = function goForward() {

          
            return this.mCurrentBrowser.goForward();
          
        
}
console.log: disabletabs: [object XULElement].reload = function reload() {

          
            return this.mCurrentBrowser.reload();
          
        
}
console.log: disabletabs: [object XULElement].reloadWithFlags = function reloadWithFlags(aFlags) {

          
            return this.mCurrentBrowser.reloadWithFlags(aFlags);
          
        
}
console.log: disabletabs: [object XULElement].stop = function stop() {

          
            return this.mCurrentBrowser.stop();
          
        
}
console.log: disabletabs: [object XULElement].loadURI = function loadURI(aURI, aReferrerURI, aCharset) {

          
            return this.mCurrentBrowser.loadURI(aURI, aReferrerURI, aCharset);
          
        
}
console.log: disabletabs: [object XULElement].loadURIWithFlags = function loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset, aPostData) {

          
            // Note - the callee understands both:
            // (a) loadURIWithFlags(aURI, aFlags, ...)
            // (b) loadURIWithFlags(aURI, { flags: aFlags, ... })
            // Forwarding it as (a) here actually supports both (a) and (b),
            // so you can call us either way too.
            return this.mCurrentBrowser.loadURIWithFlags(aURI, aFlags, aReferrerURI, aCharset, aPostData);
          
        
}
console.log: disabletabs: [object XULElement].goHome = function goHome() {

          
            return this.mCurrentBrowser.goHome();
          
        
}
console.log: disabletabs: [object XULElement].homePage = http://www.mozilla.org/
console.log: disabletabs: [object XULElement].gotoIndex = function gotoIndex(aIndex) {

          
            return this.mCurrentBrowser.gotoIndex(aIndex);
          
        
}
console.log: disabletabs: [object XULElement].attachFormFill = function attachFormFill() {

          for (let browser of this.browsers) {
            browser.attachFormFill();
          }
        
}
console.log: disabletabs: [object XULElement].detachFormFill = function detachFormFill() {

          for (let browser of this.browsers) {
            browser.detachFormFill();
          }
        
}
console.log: disabletabs: [object XULElement].currentURI = [xpconnect wrapped nsIURI]
console.log: disabletabs: [object XULElement].finder = [object Object]
console.log: disabletabs: [object XULElement].docShell = [xpconnect wrapped (nsISupports, nsIDocShell, nsIInterfaceRequestor, nsIWebProgress, nsIWebNavigation)]
console.log: disabletabs: [object XULElement].webNavigation = [xpconnect wrapped (nsISupports, nsIDocShell, nsIInterfaceRequestor, nsIWebProgress, nsIWebNavigation)]
console.log: disabletabs: [object XULElement].webBrowserFind = [xpconnect wrapped nsIWebBrowserFind]
console.log: disabletabs: [object XULElement].webProgress = [xpconnect wrapped (nsISupports, nsIDocShell, nsIInterfaceRequestor, nsIWebProgress, nsIWebNavigation)]
console.log: disabletabs: [object XULElement].contentWindow = [object Window]
console.log: disabletabs: [object XULElement].contentWindowAsCPOW = [object Window]
console.log: disabletabs: [object XULElement].sessionHistory = [xpconnect wrapped nsISHistory]
console.log: disabletabs: [object XULElement].markupDocumentViewer = [xpconnect wrapped nsIContentViewer]
console.log: disabletabs: [object XULElement].contentViewerEdit = [xpconnect wrapped (nsISupports, nsIContentViewer, nsIContentViewerEdit)]
console.log: disabletabs: [object XULElement].contentViewerFile = [xpconnect wrapped (nsISupports, nsIContentViewer, nsIContentViewerEdit, nsIContentViewerFile)]
console.log: disabletabs: [object XULElement].contentDocument = [object HTMLDocument]
console.log: disabletabs: [object XULElement].contentDocumentAsCPOW = [object HTMLDocument]
console.log: disabletabs: [object XULElement].contentTitle = 
console.log: disabletabs: [object XULElement].contentPrincipal = [xpconnect wrapped (nsISupports, nsIPrincipal, nsISerializable)]
console.log: disabletabs: [object XULElement].securityUI = [xpconnect wrapped nsISecureBrowserUI]
console.log: disabletabs: [object XULElement].fullZoom = 1
console.log: disabletabs: [object XULElement].textZoom = 1
console.log: disabletabs: [object XULElement].isSyntheticDocument = false
console.log: disabletabs: [object XULElement]._handleKeyDownEvent = function _handleKeyDownEvent(aEvent) {

          if (!aEvent.isTrusted) {
            // Don't let untrusted events mess with tabs.
            return;
          }

          if (aEvent.altKey)
            return;

          // Don't check if the event was already consumed because tab
          // navigation should always work for better user experience.

          if (aEvent.ctrlKey && aEvent.shiftKey && !aEvent.metaKey) {
            switch (aEvent.keyCode) {
              case aEvent.DOM_VK_PAGE_UP:
                this.moveTabBackward();
                aEvent.preventDefault();
                return;
              case aEvent.DOM_VK_PAGE_DOWN:
                this.moveTabForward();
                aEvent.preventDefault();
                return;
            }
          }

          if (this.AppConstants.platform != "macosx") {
            if (aEvent.ctrlKey && !aEvent.shiftKey && !aEvent.metaKey &&
                aEvent.keyCode == KeyEvent.DOM_VK_F4 &&
                !this.mCurrentTab.pinned) {
              this.removeCurrentTab({animate: true});
              aEvent.preventDefault();
            }
          }
        
}
console.log: disabletabs: [object XULElement]._handleKeyPressEventMac = function _handleKeyPressEventMac(aEvent) {

          if (!aEvent.isTrusted) {
            // Don't let untrusted events mess with tabs.
            return;
          }

          if (aEvent.altKey)
            return;

          if (this.AppConstants.platform == "macosx") {
            if (!aEvent.metaKey)
              return;

            var offset = 1;
            switch (aEvent.charCode) {
              case '}'.charCodeAt(0):
                offset = -1;
              case '{'.charCodeAt(0):
                if (window.getComputedStyle(this, null).direction == "ltr")
                  offset *= -1;
                this.tabContainer.advanceSelectedTab(offset, true);
                aEvent.preventDefault();
            }
          }
        
}
console.log: disabletabs: [object XULElement].userTypedClear = 0
console.log: disabletabs: [object XULElement].userTypedValue = null
console.log: disabletabs: [object XULElement].createTooltip = function createTooltip(event) {

          event.stopPropagation();
          var tab = document.tooltipNode;
          if (tab.localName != "tab") {
            event.preventDefault();
            return;
          }

          let stringWithShortcut = (stringId, keyElemId) => {
            let keyElem = document.getElementById(keyElemId);
            let shortcut = ShortcutUtils.prettifyShortcut(keyElem);
            return this.mStringBundle.getFormattedString(stringId, [shortcut]);
          };

          var label;
          if (tab.mOverCloseButton) {
            label = tab.selected ?
                    stringWithShortcut("tabs.closeSelectedTab.tooltip", "key_close") :
                    this.mStringBundle.getString("tabs.closeTab.tooltip");
          } else if (tab._overPlayingIcon) {
            let stringID;
            if (tab.selected) {
              stringID = tab.linkedBrowser.audioMuted ?
                "tabs.unmuteAudio.tooltip" :
                "tabs.muteAudio.tooltip";
              label = stringWithShortcut(stringID, "key_toggleMute");
            } else {
              stringID = tab.linkedBrowser.audioMuted ?
                "tabs.unmuteAudio.background.tooltip" :
                "tabs.muteAudio.background.tooltip";
              label = this.mStringBundle.getString(stringID);
            }
          } else {
            label = tab.getAttribute("label") +
                      (this.AppConstants.E10S_TESTING_ONLY && tab.linkedBrowser && tab.linkedBrowser.isRemoteBrowser ? " - e10s" : "");
          }
          event.target.setAttribute("label", label);
        
}
console.log: disabletabs: [object XULElement].handleEvent = function handleEvent(aEvent) {

          switch (aEvent.type) {
            case "keydown":
              this._handleKeyDownEvent(aEvent);
              break;
            case "keypress":
              this._handleKeyPressEventMac(aEvent);
              break;
            case "sizemodechange":
              if (aEvent.target == window) {
                this.mCurrentBrowser.docShellIsActive =
                  (window.windowState != window.STATE_MINIMIZED);
              }
              break;
          }
        
}
console.log: disabletabs: [object XULElement].receiveMessage = function receiveMessage(aMessage) {

          let json = aMessage.json;
          let browser = aMessage.target;

          switch (aMessage.name) {
            case "DOMTitleChanged": {
              let tab = this.getTabForBrowser(browser);
              if (!tab || tab.hasAttribute("pending"))
                return;
              let titleChanged = this.setTabTitle(tab);
              if (titleChanged && !tab.selected && !tab.hasAttribute("busy"))
                tab.setAttribute("titlechanged", "true");
              break;
            }
            case "DOMWindowClose": {
              if (this.tabs.length == 1) {
                window.close();
                return;
              }

              let tab = this.getTabForBrowser(browser);
              if (tab) {
                this.removeTab(tab);
              }
              break;
            }
            case "contextmenu": {
              let spellInfo = aMessage.data.spellInfo;
              if (spellInfo)
                spellInfo.target = aMessage.target.messageManager;
              let documentURIObject = makeURI(aMessage.data.docLocation,
                                              aMessage.data.charSet,
                                              makeURI(aMessage.data.baseURI));
              gContextMenuContentData = { isRemote: true,
                                          event: aMessage.objects.event,
                                          popupNode: aMessage.objects.popupNode,
                                          browser: browser,
                                          editFlags: aMessage.data.editFlags,
                                          spellInfo: spellInfo,
                                          principal: aMessage.data.principal,
                                          customMenuItems: aMessage.data.customMenuItems,
                                          addonInfo: aMessage.data.addonInfo,
                                          documentURIObject: documentURIObject,
                                          docLocation: aMessage.data.docLocation,
                                          charSet: aMessage.data.charSet,
                                          referrer: aMessage.data.referrer,
                                          referrerPolicy: aMessage.data.referrerPolicy,
                                          contentType: aMessage.data.contentType,
                                          contentDisposition: aMessage.data.contentDisposition,
                                          frameOuterWindowID: aMessage.data.frameOuterWindowID,
                                          selectionInfo: aMessage.data.selectionInfo,
                                          disableSetDesktopBackground: aMessage.data.disableSetDesktopBg,
                                          loginFillInfo: aMessage.data.loginFillInfo,
                                        };
              let popup = browser.ownerDocument.getElementById("contentAreaContextMenu");
              let event = gContextMenuContentData.event;
              popup.openPopupAtScreen(event.screenX, event.screenY, true);
              break;
            }
            case "DOMServiceWorkerFocusClient":
            case "DOMWebNotificationClicked": {
              let tab = this.getTabForBrowser(browser);
              if (!tab)
                return;
              this.selectedTab = tab;
              window.focus();
              break;
            }
            case "Browser:Init": {
              let tab = this.getTabForBrowser(browser);
              if (!tab)
                return;

              this._outerWindowIDBrowserMap.set(browser.outerWindowID, browser);
              browser.messageManager.sendAsyncMessage("Browser:AppTab", { isAppTab: tab.pinned })
              break;
            }
            case "Findbar:Keypress":
              if (!gFindBarInitialized) {
                // If the find bar for this tab is not yet alive, change that,
                // and make sure we return the result:
                return gFindBar.receiveMessage(aMessage);
              }
              break;

          }
        
}
console.log: disabletabs: [object XULElement].observe = function observe(aSubject, aTopic, aData) {

          if (aTopic == "live-resize-start") {
            let browser = this.mCurrentTab.linkedBrowser;
            let fl = browser.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader;
            if (fl && fl.tabParent && !this.mActiveResizeDisplayportSuppression) {
              fl.tabParent.suppressDisplayport(true);
              this.mActiveResizeDisplayportSuppression = browser;
            }
          } else if (aTopic == "live-resize-end") {
            let browser = this.mActiveResizeDisplayportSuppression;
            if (browser) {
              let fl = browser.QueryInterface(Ci.nsIFrameLoaderOwner).frameLoader;
              if (fl && fl.tabParent) {
                fl.tabParent.suppressDisplayport(false);
                this.mActiveResizeDisplayportSuppression = null;
              }
            }
          }
        
}
console.log: disabletabs: [object XULElement]._generateUniquePanelID = function _generateUniquePanelID() {

          if (!this._uniquePanelIDCounter) {
            this._uniquePanelIDCounter = 0;
          }

          let outerID = window.QueryInterface(Ci.nsIInterfaceRequestor)
                              .getInterface(Ci.nsIDOMWindowUtils)
                              .outerWindowID;

          // We want panel IDs to be globally unique, that's why we include the
          // window ID. We switched to a monotonic counter as Date.now() lead
          // to random failures because of colliding IDs.
          return "panel-" + outerID + "-" + (++this._uniquePanelIDCounter);
        
}
console.log: disabletabs: [object XULElement].enterTabbedMode = function enterTabbedMode() {

          Services.console.logStringMessage("enterTabbedMode is an obsolete method and " +
                                            "will be removed in a future release.");
        
}
console.log: disabletabs: [object XULElement].setStripVisibilityTo = function setStripVisibilityTo(aShow) {

          this.tabContainer.visible = aShow;
        
}
console.log: disabletabs: [object XULElement].getStripVisibility = function getStripVisibility() {

          return this.tabContainer.visible;
        
}
console.log: disabletabs: [object XULElement].mContextTab = null
console.log: disabletabs: [object XULElement].mPrefs = [xpconnect wrapped (nsISupports, nsIPrefService, nsIPrefBranch)]
console.log: disabletabs: [object XULElement].mTabContainer = [object XULElement]
console.log: disabletabs: [object XULElement].mTabs = [object NodeList]
console.log: disabletabs: [object XULElement].mStrip = [object Object]
console.log: disabletabs: [object XULElement].tabs = [object NodeList]
console.log: disabletabs: [object XULElement].closingTabsEnum = [object Object]
console.log: disabletabs: [object XULElement]._visibleTabs = [object XULElement]
console.log: disabletabs: [object XULElement].mFaviconService = [xpconnect wrapped (nsISupports, nsIFaviconService, mozIAsyncFavicons, nsITimerCallback)]
console.log: disabletabs: [object XULElement].PlacesUtils = [object Object]
console.log: disabletabs: [object XULElement]._lastRelatedTab = null
console.log: disabletabs: [object XULElement].mActiveResizeDisplayportSuppression = null
console.log: disabletabs: [object XULElement].arrowKeysShouldWrap = false
console.log: disabletabs: [object XULElement]._previewMode = false
console.log: disabletabs: [object XULElement]._lastFindValue = 
console.log: disabletabs: [object XULElement]._contentWaitingCount = 0
console.log: disabletabs: [object XULElement]._preloadedBrowser = null
console.log: disabletabs: [object XULElement]._removingTabs = 
console.log: disabletabs: [object XULElement]._windowIsClosing = false
console.log: disabletabs: [object XULElement]._browsers = [object XULElement]
console.log: disabletabs: [object XULElement]._switcher = null
console.log: disabletabs: [object XULElement].mTabbedMode = true
console.log: disabletabs: [object XULElement].focus = function focus() {
    [native code]
}
console.log: disabletabs: [object XULElement].blur = function blur() {
    [native code]
}
console.log: disabletabs: [object XULElement].click = function click() {
    [native code]
}
console.log: disabletabs: [object XULElement].doCommand = function doCommand() {
    [native code]
}
console.log: disabletabs: [object XULElement].getElementsByAttribute = function getElementsByAttribute() {
    [native code]
}
console.log: disabletabs: [object XULElement].getElementsByAttributeNS = function getElementsByAttributeNS() {
    [native code]
}
console.log: disabletabs: [object XULElement].className = 
console.log: disabletabs: [object XULElement].align = 
console.log: disabletabs: [object XULElement].dir = 
console.log: disabletabs: [object XULElement].flex = 1
console.log: disabletabs: [object XULElement].flexGroup = 
console.log: disabletabs: [object XULElement].ordinal = 
console.log: disabletabs: [object XULElement].orient = 
console.log: disabletabs: [object XULElement].pack = 
console.log: disabletabs: [object XULElement].hidden = false
console.log: disabletabs: [object XULElement].collapsed = false
console.log: disabletabs: [object XULElement].observes = 
console.log: disabletabs: [object XULElement].menu = 
console.log: disabletabs: [object XULElement].contextMenu = 
console.log: disabletabs: [object XULElement].tooltip = 
console.log: disabletabs: [object XULElement].width = 
console.log: disabletabs: [object XULElement].height = 
console.log: disabletabs: [object XULElement].minWidth = 
console.log: disabletabs: [object XULElement].minHeight = 
console.log: disabletabs: [object XULElement].maxWidth = 
console.log: disabletabs: [object XULElement].maxHeight = 
console.log: disabletabs: [object XULElement].persist = 
console.log: disabletabs: [object XULElement].left = 
console.log: disabletabs: [object XULElement].top = 
console.log: disabletabs: [object XULElement].datasources = 
console.log: disabletabs: [object XULElement].ref = 
console.log: disabletabs: [object XULElement].tooltipText = 
console.log: disabletabs: [object XULElement].statusText = 
console.log: disabletabs: [object XULElement].allowEvents = false
console.log: disabletabs: [object XULElement].database = null
console.log: disabletabs: [object XULElement].builder = null
console.log: disabletabs: [object XULElement].resource = [xpconnect wrapped nsIRDFResource]
console.log: disabletabs: [object XULElement].controllers = [object XULControllers]
console.log: disabletabs: [object XULElement].boxObject = [object BoxObject]
console.log: disabletabs: [object XULElement].style = [object CSS2Properties]
console.log: disabletabs: [object XULElement].onabort = null
console.log: disabletabs: [object XULElement].onblur = null
console.log: disabletabs: [object XULElement].onfocus = null
console.log: disabletabs: [object XULElement].oncanplay = null
console.log: disabletabs: [object XULElement].oncanplaythrough = null
console.log: disabletabs: [object XULElement].onchange = null
console.log: disabletabs: [object XULElement].onclick = null
console.log: disabletabs: [object XULElement].oncontextmenu = null
console.log: disabletabs: [object XULElement].ondblclick = null
console.log: disabletabs: [object XULElement].ondrag = null
console.log: disabletabs: [object XULElement].ondragend = null
console.log: disabletabs: [object XULElement].ondragenter = null
console.log: disabletabs: [object XULElement].ondragleave = null
console.log: disabletabs: [object XULElement].ondragover = null
console.log: disabletabs: [object XULElement].ondragstart = null
console.log: disabletabs: [object XULElement].ondrop = null
console.log: disabletabs: [object XULElement].ondurationchange = null
console.log: disabletabs: [object XULElement].onemptied = null
console.log: disabletabs: [object XULElement].onended = null
console.log: disabletabs: [object XULElement].oninput = null
console.log: disabletabs: [object XULElement].oninvalid = null
console.log: disabletabs: [object XULElement].onkeydown = null
console.log: disabletabs: [object XULElement].onkeypress = null
console.log: disabletabs: [object XULElement].onkeyup = null
console.log: disabletabs: [object XULElement].onload = null
console.log: disabletabs: [object XULElement].onloadeddata = null
console.log: disabletabs: [object XULElement].onloadedmetadata = null
console.log: disabletabs: [object XULElement].onloadstart = null
console.log: disabletabs: [object XULElement].onmousedown = null
console.log: disabletabs: [object XULElement].onmouseenter = null
console.log: disabletabs: [object XULElement].onmouseleave = null
console.log: disabletabs: [object XULElement].onmousemove = null
console.log: disabletabs: [object XULElement].onmouseout = null
console.log: disabletabs: [object XULElement].onmouseover = null
console.log: disabletabs: [object XULElement].onmouseup = null
console.log: disabletabs: [object XULElement].onpause = null
console.log: disabletabs: [object XULElement].onplay = null
console.log: disabletabs: [object XULElement].onplaying = null
console.log: disabletabs: [object XULElement].onprogress = null
console.log: disabletabs: [object XULElement].onratechange = null
console.log: disabletabs: [object XULElement].onreset = null
console.log: disabletabs: [object XULElement].onresize = null
console.log: disabletabs: [object XULElement].onscroll = null
console.log: disabletabs: [object XULElement].onseeked = null
console.log: disabletabs: [object XULElement].onseeking = null
console.log: disabletabs: [object XULElement].onselect = null
console.log: disabletabs: [object XULElement].onshow = null
console.log: disabletabs: [object XULElement].onstalled = null
console.log: disabletabs: [object XULElement].onsubmit = null
console.log: disabletabs: [object XULElement].onsuspend = null
console.log: disabletabs: [object XULElement].ontimeupdate = null
console.log: disabletabs: [object XULElement].onvolumechange = null
console.log: disabletabs: [object XULElement].onwaiting = null
console.log: disabletabs: [object XULElement].onmozfullscreenchange = null
console.log: disabletabs: [object XULElement].onmozfullscreenerror = null
console.log: disabletabs: [object XULElement].onmozpointerlockchange = null
console.log: disabletabs: [object XULElement].onmozpointerlockerror = null
console.log: disabletabs: [object XULElement].onerror = null
console.log: disabletabs: [object XULElement].setIsPrerendered = function setIsPrerendered() {
    [native code]
}
console.log: disabletabs: [object XULElement].swapFrameLoaders = function swapFrameLoaders() {
    [native code]
}
console.log: disabletabs: [object XULElement].frameLoader = null
console.log: disabletabs: [object XULElement].getAttribute = function getAttribute() {
    [native code]
}
console.log: disabletabs: [object XULElement].getAttributeNS = function getAttributeNS() {
    [native code]
}
console.log: disabletabs: [object XULElement].setAttribute = function setAttribute() {
    [native code]
}
console.log: disabletabs: [object XULElement].setAttributeNS = function setAttributeNS() {
    [native code]
}
console.log: disabletabs: [object XULElement].removeAttribute = function removeAttribute() {
    [native code]
}
console.log: disabletabs: [object XULElement].removeAttributeNS = function removeAttributeNS() {
    [native code]
}
console.log: disabletabs: [object XULElement].hasAttribute = function hasAttribute() {
    [native code]
}
console.log: disabletabs: [object XULElement].hasAttributeNS = function hasAttributeNS() {
    [native code]
}
console.log: disabletabs: [object XULElement].hasAttributes = function hasAttributes() {
    [native code]
}
console.log: disabletabs: [object XULElement].closest = function closest() {
    [native code]
}
console.log: disabletabs: [object XULElement].matches = function matches() {
    [native code]
}
console.log: disabletabs: [object XULElement].webkitMatchesSelector = function webkitMatchesSelector() {
    [native code]
}
console.log: disabletabs: [object XULElement].getElementsByTagName = function getElementsByTagName() {
    [native code]
}
console.log: disabletabs: [object XULElement].getElementsByTagNameNS = function getElementsByTagNameNS() {
    [native code]
}
console.log: disabletabs: [object XULElement].getElementsByClassName = function getElementsByClassName() {
    [native code]
}
console.log: disabletabs: [object XULElement].mozMatchesSelector = function mozMatchesSelector() {
    [native code]
}
console.log: disabletabs: [object XULElement].setCapture = function setCapture() {
    [native code]
}
console.log: disabletabs: [object XULElement].releaseCapture = function releaseCapture() {
    [native code]
}
console.log: disabletabs: [object XULElement].mozRequestFullScreen = function mozRequestFullScreen() {
    [native code]
}
console.log: disabletabs: [object XULElement].mozRequestPointerLock = function mozRequestPointerLock() {
    [native code]
}
console.log: disabletabs: [object XULElement].getAttributeNode = function getAttributeNode() {
    [native code]
}
console.log: disabletabs: [object XULElement].setAttributeNode = function setAttributeNode() {
    [native code]
}
console.log: disabletabs: [object XULElement].removeAttributeNode = function removeAttributeNode() {
    [native code]
}
console.log: disabletabs: [object XULElement].getAttributeNodeNS = function getAttributeNodeNS() {
    [native code]
}
console.log: disabletabs: [object XULElement].setAttributeNodeNS = function setAttributeNodeNS() {
    [native code]
}
console.log: disabletabs: [object XULElement].getClientRects = function getClientRects() {
    [native code]
}
console.log: disabletabs: [object XULElement].getBoundingClientRect = function getBoundingClientRect() {
    [native code]
}
console.log: disabletabs: [object XULElement].scrollIntoView = function scrollIntoView() {
    [native code]
}
console.log: disabletabs: [object XULElement].scroll = function scroll() {
    [native code]
}
console.log: disabletabs: [object XULElement].scrollTo = function scrollTo() {
    [native code]
}
console.log: disabletabs: [object XULElement].scrollBy = function scrollBy() {
    [native code]
}
console.log: disabletabs: [object XULElement].insertAdjacentHTML = function insertAdjacentHTML() {
    [native code]
}
console.log: disabletabs: [object XULElement].querySelector = function querySelector() {
    [native code]
}
console.log: disabletabs: [object XULElement].querySelectorAll = function querySelectorAll() {
    [native code]
}
console.log: disabletabs: [object XULElement].createShadowRoot = function createShadowRoot() {
    [native code]
}
console.log: disabletabs: [object XULElement].getDestinationInsertionPoints = function getDestinationInsertionPoints() {
    [native code]
}
console.log: disabletabs: [object XULElement].getAnimations = function getAnimations() {
    [native code]
}
console.log: disabletabs: [object XULElement].remove = function remove() {
    [native code]
}
console.log: disabletabs: [object XULElement].getBoxQuads = function getBoxQuads() {
    [native code]
}
console.log: disabletabs: [object XULElement].tagName = tabbrowser
console.log: disabletabs: [object XULElement].id = content
console.log: disabletabs: [object XULElement].classList = 
console.log: disabletabs: [object XULElement].attributes = [object NamedNodeMap]
console.log: disabletabs: [object XULElement].onwheel = null
console.log: disabletabs: [object XULElement].scrollTop = 0
console.log: disabletabs: [object XULElement].scrollLeft = 0
console.log: disabletabs: [object XULElement].scrollWidth = 25
console.log: disabletabs: [object XULElement].scrollHeight = 25
console.log: disabletabs: [object XULElement].clientTop = 0
console.log: disabletabs: [object XULElement].clientLeft = 0
console.log: disabletabs: [object XULElement].clientWidth = 25
console.log: disabletabs: [object XULElement].clientHeight = 25
console.log: disabletabs: [object XULElement].scrollTopMax = 0
console.log: disabletabs: [object XULElement].scrollLeftMax = 0
console.log: disabletabs: [object XULElement].innerHTML = <panel xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" class="autoscroller" mousethrough="always" id="autoscroller"/>
console.log: disabletabs: [object XULElement].outerHTML = <tabbrowser xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" id="content" flex="1" contenttooltip="aHTMLTooltip" tabcontainer="tabbrowser-tabs" contentcontextmenu="contentAreaContextMenu" autocompletepopup="PopupAutoComplete" selectmenulist="ContentSelectDropdown" style="background-color: rgb(255, 255, 255);"><panel class="autoscroller" mousethrough="always" id="autoscroller"/></tabbrowser>
console.log: disabletabs: [object XULElement].shadowRoot = null
console.log: disabletabs: [object XULElement].previousElementSibling = [object XULElement]
console.log: disabletabs: [object XULElement].nextElementSibling = [object XULElement]
console.log: disabletabs: [object XULElement].children = [object HTMLCollection]
console.log: disabletabs: [object XULElement].firstElementChild = [object XULElement]
console.log: disabletabs: [object XULElement].lastElementChild = [object XULElement]
console.log: disabletabs: [object XULElement].childElementCount = 1
console.log: disabletabs: [object XULElement].scrollByNoFlush = function scrollByNoFlush() {
    [native code]
}
console.log: disabletabs: [object XULElement].mozScrollSnap = function mozScrollSnap() {
    [native code]
}
console.log: disabletabs: [object XULElement].fontSizeInflation = 1
console.log: disabletabs: [object XULElement].scrollTopMin = 0
console.log: disabletabs: [object XULElement].scrollLeftMin = 0
console.log: disabletabs: [object XULElement].hasChildNodes = function hasChildNodes() {
    [native code]
}
console.log: disabletabs: [object XULElement].insertBefore = function insertBefore() {
    [native code]
}
console.log: disabletabs: [object XULElement].appendChild = function appendChild() {
    [native code]
}
console.log: disabletabs: [object XULElement].replaceChild = function replaceChild() {
    [native code]
}
console.log: disabletabs: [object XULElement].removeChild = function removeChild() {
    [native code]
}
console.log: disabletabs: [object XULElement].normalize = function normalize() {
    [native code]
}
console.log: disabletabs: [object XULElement].cloneNode = function cloneNode() {
    [native code]
}
console.log: disabletabs: [object XULElement].isEqualNode = function isEqualNode() {
    [native code]
}
console.log: disabletabs: [object XULElement].compareDocumentPosition = function compareDocumentPosition() {
    [native code]
}
console.log: disabletabs: [object XULElement].contains = function contains() {
    [native code]
}
console.log: disabletabs: [object XULElement].lookupPrefix = function lookupPrefix() {
    [native code]
}
console.log: disabletabs: [object XULElement].lookupNamespaceURI = function lookupNamespaceURI() {
    [native code]
}
console.log: disabletabs: [object XULElement].isDefaultNamespace = function isDefaultNamespace() {
    [native code]
}
console.log: disabletabs: [object XULElement].setUserData = function setUserData() {
    [native code]
}
console.log: disabletabs: [object XULElement].getUserData = function getUserData() {
    [native code]
}
console.log: disabletabs: [object XULElement].nodeType = 1
console.log: disabletabs: [object XULElement].nodeName = tabbrowser
console.log: disabletabs: [object XULElement].baseURI = chrome://browser/content/browser.xul
console.log: disabletabs: [object XULElement].ownerDocument = [object XULDocument]
console.log: disabletabs: [object XULElement].parentNode = [object XULElement]
console.log: disabletabs: [object XULElement].parentElement = [object XULElement]
console.log: disabletabs: [object XULElement].childNodes = [object NodeList]
console.log: disabletabs: [object XULElement].firstChild = [object XULElement]
console.log: disabletabs: [object XULElement].lastChild = [object XULElement]
console.log: disabletabs: [object XULElement].previousSibling = [object XULElement]
console.log: disabletabs: [object XULElement].nextSibling = [object XULElement]
console.log: disabletabs: [object XULElement].nodeValue = null
console.log: disabletabs: [object XULElement].textContent = 
console.log: disabletabs: [object XULElement].namespaceURI = http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul
console.log: disabletabs: [object XULElement].prefix = null
console.log: disabletabs: [object XULElement].localName = tabbrowser
console.log: disabletabs: [object XULElement].ELEMENT_NODE = 1
console.log: disabletabs: [object XULElement].ATTRIBUTE_NODE = 2
console.log: disabletabs: [object XULElement].TEXT_NODE = 3
console.log: disabletabs: [object XULElement].CDATA_SECTION_NODE = 4
console.log: disabletabs: [object XULElement].ENTITY_REFERENCE_NODE = 5
console.log: disabletabs: [object XULElement].ENTITY_NODE = 6
console.log: disabletabs: [object XULElement].PROCESSING_INSTRUCTION_NODE = 7
console.log: disabletabs: [object XULElement].COMMENT_NODE = 8
console.log: disabletabs: [object XULElement].DOCUMENT_NODE = 9
console.log: disabletabs: [object XULElement].DOCUMENT_TYPE_NODE = 10
console.log: disabletabs: [object XULElement].DOCUMENT_FRAGMENT_NODE = 11
console.log: disabletabs: [object XULElement].NOTATION_NODE = 12
console.log: disabletabs: [object XULElement].DOCUMENT_POSITION_DISCONNECTED = 1
console.log: disabletabs: [object XULElement].DOCUMENT_POSITION_PRECEDING = 2
console.log: disabletabs: [object XULElement].DOCUMENT_POSITION_FOLLOWING = 4
console.log: disabletabs: [object XULElement].DOCUMENT_POSITION_CONTAINS = 8
console.log: disabletabs: [object XULElement].DOCUMENT_POSITION_CONTAINED_BY = 16
console.log: disabletabs: [object XULElement].DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32
console.log: disabletabs: [object XULElement].getBoundMutationObservers = function getBoundMutationObservers() {
    [native code]
}
console.log: disabletabs: [object XULElement].nodePrincipal = [xpconnect wrapped (nsISupports, nsIPrincipal, nsISerializable)]
console.log: disabletabs: [object XULElement].baseURIObject = [xpconnect wrapped nsIURI]
console.log: disabletabs: [object XULElement].addEventListener = function addEventListener() {
    [native code]
}
console.log: disabletabs: [object XULElement].removeEventListener = function removeEventListener() {
    [native code]
}
console.log: disabletabs: [object XULElement].dispatchEvent = function dispatchEvent() {
    [native code]
}
console.log: disabletabs: [object XULElement].setEventHandler = function setEventHandler() {
    [native code]
}
console.log: disabletabs: [object XULElement].getEventHandler = function getEventHandler() {
    [native code]
}
console.log: disabletabs: [object XULElement].ownerGlobal = [object ChromeWindow]
console.log: disabletabs: /properties of [object XULElement]
